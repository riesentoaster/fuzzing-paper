\documentclass{article}
\usepackage{hyperref}
\usepackage{csquotes}
\usepackage{geometry}
\usepackage{longtable}
\usepackage{array}
\usepackage[style=ieee]{biblatex}
\addbibresource{sources.bib}
\usepackage{todonotes}

\title{The History of Symbolic Execution in Fuzzing}
\author{Valentin Huber}
\begin{document}
\include{settings}

\maketitle

\todo{Abstract}

\tableofcontents

\section{Introduction}
\begin{itemize}
    \item \textquote{Today, testing is the primary way to check the correctness of software. Billions of dollars are spent on testing in the software industry, as testing usually accounts for about 50\% of the cost of software development. It was recently estimated that software failures currently cost the US economy alone about \$60 billion every year, and that improvements in software testing infrastructure might save one-third of this cost.}\cite{DART}
    \item \textquote{There are many different dynamic analyses that can be described as “fuzzing.” A unifying feature of fuzzers is that they operate on, and produce, concrete inputs. Otherwise, fuzzers might be instantiated with many different design choices and many different parameter settings.}\cite{EvaluatingFuzzTesting}
\end{itemize}

\section{Theoretical Principles}
\begin{itemize}
    \item Two approaches: Random mutation as described in \textit{An Empirical Study of the Reliability of UNIX Utilities} by Miller et al.\cite{UNIX} and pure symbolic execution.
    \item The latter is infeasible for large programs and for any program that interacts with the environment, the former in its purest form is not very effective.
          \begin{itemize}
              \item \textquote{A key disadvantage of classical symbolic execution is that it cannot generate an input if the symbolic path constraint along a feasible execution path contains formulas that cannot be (efficiently) solved by a constraint solver (for example, nonlinear constraints).}\cite{ReviewThreeDecades}
              \item \textquote{The blackbox and whitebox strategies achieved similar results in all categories. This shows that, when testing applications with highly-structured inputs in a limited amount of time (2 hours), whitebox fuzzing, with the power of symbolic execution, does not improve much over simple blackbox fuzzing. In fact, in the code generator, those grammar-less strategies do not improve coverage much above the initial set of seed inputs.}\cite{GrammarBasedWhiteboxFuzzing}
          \end{itemize}
    \item Generally:
          \begin{itemize}
              \item \textquote{The process begins by choosing a corpus of “seed” inputs with which to test the target program. The fuzzer then repeatedly mutates these inputs and evaluates the program under test. If the result produces “interesting” behavior, the fuzzer keeps the mutated input for future use and records what was observed. Eventually the fuzzer stops, either due to reaching a particular goal (e.g., finding a certain sort of bug) or reaching a timeout.}\cite{EvaluatingFuzzTesting}
              \item \textquote{Different fuzzers record different observations when running the program under test. In a “black box” fuzzer, a single observation is made: whether the program crashed. In “gray box” fuzzing, observations also consist of intermediate information about the execution, for example, the branches taken during execution as determined by pairs of basic block identifiers executed directly in sequence. “White box” fuzzers can make observations and modifications by exploiting the semantics of application source (or binary) code, possibly involving sophisticated reasoning. Gathering additional observations adds overhead. Different fuzzers make different choices, hoping to trade higher overhead for better bug-finding effectiveness.}\cite{EvaluatingFuzzTesting}
              \item \textquote{In any of these cases, the output from the fuzzer is some concrete input(s) and configurations that can be used from outside of the fuzzer to reproduce the observation. This allows software developers to confirm, reproduce, and debug issues.}\cite{EvaluatingFuzzTesting}
          \end{itemize}
    \item With time and in many projects, parts of one approach has been introduced to the other to use where one excels to aid where the other has drawbacks.
    \item Further approaches have also been introduced into the mix.
\end{itemize}

\subsection{Problems and Mitigation}
Heavily based on \cite{ReviewThreeDecades}.

\subsubsection{Impossible Constraints}
\begin{itemize}
    \item \textquote{A key disadvantage of classical symbolic execution is that it cannot generate an input if the symbolic path constraint along a feasible execution path contains formulas that cannot be (efficiently) solved by a constraint solver (for example, nonlinear constraints).}\cite{ReviewThreeDecades}
    \item Two techniques that alleviate this problem:
          \begin{itemize}
              \item Concolic Testing (like DART\cite{DART}): Run concrete and symbolic execution at the same time, keep mapping between values, solve path constraint with one sub-constraint flipped to get input for an other path.
              \item Execution-Generated Testing (EGT) (like EXE\cite{EXE} and KLEE\cite{KLEE}): Only execute symbolically if any operands are symbolic
          \end{itemize}
    \item These handle imprecision in symbex (like interaction with outside code (that is not instrumented for symbex), constraint solving timeouts, unhandled instructions (floating point), or system calls) by just using concrete values.
          \begin{itemize}
              \item If none of the operands are symbolically, just use them
              \item If any are, use the concrete values (direct in concolic, solution from path constraint in EGT)
          \end{itemize}
    \item Downside: missing some feasible paths, and therefore sacrificing completeness.
\end{itemize}

\subsubsection{Path Explosion}
Path Explosion: program path count usually exponential in the number of static branches in the code.
\begin{itemize}
    \item Symbex helps by only looking at possible branches. Example: EXE\cite{EXE} on \code{tcpdump}: only 42\% of instructions contained symbolic operands, less than 20\% of of symbolic branches have both sides feasible\cite{EXE}
    \item Prioritization of which path to explore next using heuristics (like statement or branch coverage (and using static analysis to guide), favouring statements that were run the fewest number of times, or random)
    \item Interleave random and symbolic execution
    \item Pruning redundant paths (\textquote{if a program path reaches the same program point with the same symbolic constraints as a previously explored path, then this path will continue to execute exactly the same from that point on and thus can be discarded.}\cite{RWset})
    \item Lazy test generation
    \item Static path merging
\end{itemize}

\subsubsection{Constraint Solving}
Dominates runtime
\begin{itemize}
    \item Irrelevant constraint elimination: Generally, we go from a solvable constraint set (namely the current execution with the solution being the current concrete values) to one where only one constraint changes (the one we flipped). Typically, major major parts of the constraint set are not influenced by the change and can be excluded from what is passed to the solver. We can then just use the values from the previous iteration.
    \item Incremental solving: Reuse the results of previous similar queries, because subsets of the constraints are still solved by the same results and supersets often do not invalidate existing solutions.
\end{itemize}

\subsubsection{Memory Modelling}
Things like modelling \code{int}s as mathematical integers being imprecise since it ignores over-/underflows, and pointers being hard to deal with. \textquote{On the one end of the spectrum is a system like DART\cite{DART} that only reasons about concrete pointers, or systems like CUTE\cite{CUTE} and CREST\cite{CREST} that support only equality and inequality constraints for pointers, which can be efficiently solved.35 At the other end are systems like EXE\cite{EXE}, and more recently KLEE\cite{KLEE} and SAGE\cite{SAGE} that model pointers using the theory of arrays with selections and updates implemented by solvers like STP or Z3.}\cite{ReviewThreeDecades}

\subsubsection{Handling Concurrency}
Testing usually difficult because of the inherent non-determinism. \textquote{Concolic testing was successfully combined with a variant of partial order reduction to test concurrent programs effectively.}\cite{ReviewThreeDecades}

\section{Improvements in Papers}
\todo{Filter for symbex}
\begin{itemize}
    \item Initial seed selection: up-front analysis\cite{Skyfire, Orthrus, DIFUZE}, grammar\cite{QuickFuzz, QuickFuzz2}
    \item Mutation: symbex to choose how many bits to flip\cite{SYMFUZZ}, taint analysis\cite{Mayhem, Angora, Steelix, VUzzer}, dynamic slicing\cite{MutaGen}, seed properties\cite{SDF}, grammars\cite{SCADA, IMF}, language constructs knowledge\cite{Chizpurfle}
    \item Eval: symbex when stuck\cite{Driller, Mayhem}, general symbex\cite{S2F}, speedup through OS optimizations\cite{OS} or other low-level primitives\cite{IMF, VDF, kAFL}, removing checks\cite{TFuzz}, fine-grained runtime analysis\cite{MEDS}
    \item Observation: longer running time\cite{SlowFuzz}, different behavior\cite{NEZHA}, additional instrumentation\cite{Steelix, Angora}, static analysis-guided searching\cite{Dowser, VUzzer}
    \item Seed selection: areas of interest reached\cite{AFLGo, CGF, FairFuzz, VUzzer}, different algorithm\cite{SeedSelection, Scheduling}
\end{itemize}


\section{Related Works and Methods}
\begin{itemize}
    \item Large scientific body of work
    \item Review papers
          \begin{itemize}
              \item Well cited
              \item New
              \item Specific topics to see if challenges and solutions differ
          \end{itemize}
\end{itemize}

\subsection{Survey Papers}
\subsubsection{General Survey Papers}
\begin{itemize}
    \item    Symbolic execution for software testing in practice: preliminary assessment (\citeyear{PreliminaryAssessment})\cite{PreliminaryAssessment}
    \item    Fuzzing: The State of the Art (\citeyear{FuzzingTheStateOfTheArt})\cite{FuzzingTheStateOfTheArt}
    \item    Symbolic execution for software testing: three decades later (\citeyear{ReviewThreeDecades})\cite{ReviewThreeDecades}
    \item    A systematic review of fuzzing techniques (\citeyear{Science})\cite{Science}
    \item    Fuzzing: A Survey (\citeyear{FuzzingASurvey})\cite{FuzzingASurvey}
    \item    Fuzzing: State of the Art (\citeyear{FuzzingStateOfTheArt2018})\cite{FuzzingStateOfTheArt2018}
    \item    Evaluating Fuzz Testing (\citeyear{EvaluatingFuzzTesting})\cite{EvaluatingFuzzTesting}
    \item    Fuzzing: hack, art, and science (\citeyear{HackArtScience})\cite{HackArtScience}
    \item    A Systematic Review of Search Strategies in Dynamic Symbolic Execution (\citeyear{SearchStrategies})\cite{SearchStrategies}
    \item    Fuzzing: Challenges and Reflections (\citeyear{ChallengesAndReflections})\cite{ChallengesAndReflections}
    \item    Exploratory Review of Hybrid Fuzzing for Automated Vulnerability Detection (\citeyear{Hybrid})\cite{Hybrid}
    \item    The Art, Science, and Engineering of Fuzzing: A Survey (\citeyear{ArtScienceEngineeringFuzzing})\cite{ArtScienceEngineeringFuzzing}
    \item    Fuzzing: A Survey for Roadmap (\citeyear{FuzzingASurveyforRoadmap})\cite{FuzzingASurveyforRoadmap}
    \item    Fuzzing vulnerability discovery techniques: Survey, challenges and future directions (\citeyear{FuzzingVulnerabilityDiscoveryTechniques})\cite{FuzzingVulnerabilityDiscoveryTechniques}
    \item    Demystify the Fuzzing Methods: A Comprehensive Survey (\citeyear{Demystifying})\cite{Demystifying}
    \item    A systematic review of fuzzing (\citeyear{SystematicReview2023})\cite{SystematicReview2023}
\end{itemize}

\subsubsection{Specific Survey Papers}
\begin{itemize}
    \item    Network protocol fuzz testing for information systems and applications: a survey and taxonomy (\citeyear{Network})\cite{Network}
    \item    A Survey of Dynamic Analysis and Test Generation for JavaScript (\citeyear{JavaScript2})\cite{JavaScript2}
    \item    Fuzzing the Internet of Things: A Review on the Techniques and Challenges for Efficient Vulnerability Discovery in Embedded Systems (\citeyear{IoT})\cite{IoT}
    \item    Firmware Fuzzing: The State of the Art (\citeyear{Firmware})\cite{Firmware}
    \item    Research on Fuzzing Technology for JavaScript Engines (\citeyear{JavaScript})\cite{JavaScript}
    \item    Ethereum Smart Contract Analysis Tools: A Systematic Review (\citeyear{Ethereum})\cite{Ethereum}
    \item    A Survey on the Development of Network Protocol Fuzzing Techniques (\citeyear{Network2023})\cite{Network2023}
    \item    Embedded fuzzing: a review of challenges, tools, and solutions (\citeyear{Embedded2})\cite{Embedded2}
    \item    Fuzzing of Embedded Systems: A Survey (\citeyear{Embedded})\cite{Embedded}
\end{itemize}

\section{Conclusions}

\subsection{Future Work}

\pagebreak
\addcontentsline{toc}{section}{Bibliography}
\printbibliography[]

\end{document}
