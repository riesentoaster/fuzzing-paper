\documentclass{article}
\usepackage{hyperref}
\usepackage{csquotes}
\usepackage{geometry}
\usepackage{longtable}
\usepackage{array}
\usepackage[style=ieee]{biblatex}
\addbibresource{sources.bib}
\usepackage{todonotes}

\title{Looking at Challenges and Mitigation in Symbolic Execution Based Fuzzing Through the Lens of Survey Papers}
\author{Valentin Huber}
\begin{document}
\include{settings}

\maketitle

\todo{Abstract}

\tableofcontents

\section{Introduction}
\begin{itemize}
    \item \textquote{Today, testing is the primary way to check the correctness of software. Billions of dollars are spent on testing in the software industry, as testing usually accounts for about 50\% of the cost of software development. It was recently estimated that software failures currently cost the US economy alone about \$60 billion every year, and that improvements in software testing infrastructure might save one-third of this cost.}\cite{DART}
    \item \textquote{Software testing is the most commonly used technique for validating the quality of software, but it is typically a mostly manual process that accounts for a large fraction of software development and maintenance.}\cite{PreliminaryAssessment}
    \item \textquote{There are many different dynamic analyses that can be described as “fuzzing.” A unifying feature of fuzzers is that they operate on, and produce, concrete inputs. Otherwise, fuzzers might be instantiated with many different design choices and many different parameter settings.}\cite{EvaluatingFuzzTesting}
\end{itemize}

\section{Theoretical Principles}
\begin{itemize}
    \item Two approaches: Random mutation as described in \textit{An Empirical Study of the Reliability of UNIX Utilities} by Miller et al.\cite{UNIX} and pure symbolic execution.
    \item The latter is infeasible for large programs and for any program that interacts with the environment, the former in its purest form is not very effective.
          \begin{itemize}
              \item \textquote{A key disadvantage of classical symbolic execution is that it cannot generate an input if the symbolic path constraint along a feasible execution path contains formulas that cannot be (efficiently) solved by a constraint solver (for example, nonlinear constraints).}\cite{ReviewThreeDecades}
              \item \textquote{The blackbox and whitebox strategies achieved similar results in all categories. This shows that, when testing applications with highly-structured inputs in a limited amount of time (2 hours), whitebox fuzzing, with the power of symbolic execution, does not improve much over simple blackbox fuzzing. In fact, in the code generator, those grammar-less strategies do not improve coverage much above the initial set of seed inputs.}\cite{GrammarBasedWhiteboxFuzzing}
          \end{itemize}
    \item Generally:
          \begin{itemize}
              \item \textquote{The process begins by choosing a corpus of “seed” inputs with which to test the target program. The fuzzer then repeatedly mutates these inputs and evaluates the program under test. If the result produces “interesting” behavior, the fuzzer keeps the mutated input for future use and records what was observed. Eventually the fuzzer stops, either due to reaching a particular goal (e.g., finding a certain sort of bug) or reaching a timeout.}\cite{EvaluatingFuzzTesting}
              \item \textquote{Different fuzzers record different observations when running the program under test. In a “black box” fuzzer, a single observation is made: whether the program crashed. In “gray box” fuzzing, observations also consist of intermediate information about the execution, for example, the branches taken during execution as determined by pairs of basic block identifiers executed directly in sequence. “White box” fuzzers can make observations and modifications by exploiting the semantics of application source (or binary) code, possibly involving sophisticated reasoning. Gathering additional observations adds overhead. Different fuzzers make different choices, hoping to trade higher overhead for better bug-finding effectiveness.}\cite{EvaluatingFuzzTesting}
              \item \textquote{In any of these cases, the output from the fuzzer is some concrete input(s) and configurations that can be used from outside of the fuzzer to reproduce the observation. This allows software developers to confirm, reproduce, and debug issues.}\cite{EvaluatingFuzzTesting}
          \end{itemize}
    \item With time and in many projects, parts of one approach has been introduced to the other to use where one excels to aid where the other has drawbacks.
    \item Further approaches have also been introduced into the mix.
\end{itemize}

\subsection{Problems and Mitigation}
Heavily based on \cite{ReviewThreeDecades, PreliminaryAssessment}.

\subsubsection{Impossible Constraints}
\begin{itemize}
    \item \textquote{A key disadvantage of classical symbolic execution is that it cannot generate an input if the symbolic path constraint along a feasible execution path contains formulas that cannot be (efficiently) solved by a constraint solver (for example, nonlinear constraints).}\cite{ReviewThreeDecades}
    \item Two techniques that alleviate this problem:
          \begin{itemize}
              \item Concolic Testing (like DART\cite{DART} and its successor CUTE\cite{CUTE}, and CREST\cite{CREST}): Run concrete and symbolic execution at the same time, keep mapping between values, solve path constraint with one sub-constraint flipped to get input for an other path. \textquote{A key observation in DART is that imprecision in symbolic execution can be alleviated using concrete values and randomization}\cite{PreliminaryAssessment}
              \item Execution-Generated Testing (EGT)\cite{EGT} (like EXE\cite{EXE} and KLEE\cite{KLEE}): Only execute symbolically if any operands are symbolic
          \end{itemize}
    \item These handle imprecision in symbex (like interaction with outside code (that is not instrumented for symbex), constraint solving timeouts, unhandled instructions (floating point), or system calls) by just using concrete values.
          \begin{itemize}
              \item If none of the operands are symbolically, just use them
              \item If any are, use the concrete values (direct in concolic, solution from path constraint in EGT)
          \end{itemize}
    \item Downside: missing some feasible paths, and therefore sacrificing completeness.
    \item Further Ideas: Special Constraint Solvers that improve floating point based constraint handling (like FloPSy\cite{FloPSy}) and complex mathematical constraints (like CORAL\cite{CORAL})
\end{itemize}

\subsubsection{Environment Interaction}
\begin{itemize}
    \item \textquote{[…KLEE's\cite{KLEE}] ability to handle interactions with the outside environment — e.g., with data read from the file system or over the network — by providing models designed to explore all possible legal interactions with the outside world.}\cite{PreliminaryAssessment}
\end{itemize}

\subsubsection{Path Explosion}
Path Explosion: program path count usually exponential in the number of static branches in the code.
\begin{itemize}
    \item Symbex inherently helps by only looking at possible branches. Example: EXE\cite{EXE} on \code{tcpdump}: only 42\% of instructions contained symbolic operands, less than 20\% of of symbolic branches have both sides feasible\cite{EXE}
    \item Prioritization of which path to explore next using heuristics (like statement or branch coverage (and using static analysis to guide), favouring statements that were run the fewest number of times, or random). Examples: EXE\cite{EXE}, SAGE\cite{SAGE}, CREST\cite{CREST}
          \begin{itemize}
              \item Interleave random and symbolic execution. Examples: Hybrid Concolic Testing\cite{HCT}
              \item Guide towards changes in a patch: Directed Incremental Symbolic Execution\cite{DiSE} and Directed Test Suite Augmentation\cite{DTSA}
              \item parallel state-space search algorithms like generational search: SAGE\cite{SAGE}
              \item \textquote{CREST\cite{CREST} is an extensible platform for building and experimenting with heuristics for selecting which paths to explore}\cite{ReviewThreeDecades}
              \item \textquote{we propose a novel approach called Fitnex, a search strategy that uses state-dependent fitness values (computed through a fitness function) to guide path exploration. The fitness function measures how close an already discovered feasible path is to a particular test target (e.g., covering a not-yet-covered branch)}\cite{Fitnex}
          \end{itemize}
    \item Pruning redundant paths (\textquote{if a program path reaches the same program point with the same symbolic constraints as a previously explored path, then this path will continue to execute exactly the same from that point on and thus can be discarded.}\cite{RWset}) Eliminating redundant paths by analyzing the values read and written by the program.
    \item Sharing among states/copy on write: KLEE\cite{KLEE}
    \item Caching function summaries for later use by higher-level functions. Example: SMART\cite{SMART}
    \item Lazy test generation (as in LATEST\cite{LATEST})
    \item Static path merging (as in KLEE-FP\cite{KLEEFP})
    \item partial order and symmetry reductions (as in GSE\cite{GSE})
    \item Compact representation of path constraints (as in SAGE\cite{SAGE})
\end{itemize}

\subsubsection{Constraint Solving}
Dominates runtime
\begin{itemize}
    \item Irrelevant constraint elimination: Generally, we go from a solvable constraint set (namely the current execution with the solution being the current concrete values) to one where only one constraint changes (the one we flipped). Typically, major major parts of the constraint set are not influenced by the change and can be excluded from what is passed to the solver. We can then just use the values from the previous iteration.
    \item Mocking and stubbing: Moles\cite{Moles}
    \item Incremental solving: Reuse the results of previous similar queries, because subsets of the constraints are still solved by the same results and supersets often do not invalidate existing solutions. (CUTE\cite{CUTE} and counterexample caching scheme in KLEE\cite{KLEE})
    \item Improved SMT solvers (like Z3\cite{Z3} used in e.g. SAGE\cite{SAGE}, or STP\cite{STP} built during the development of EXE\cite{EXE})
\end{itemize}

\subsubsection{Memory Modelling}
Things like modelling \code{int}s as mathematical integers being imprecise since it ignores over-/underflows, and pointers being hard to deal with. \textquote{On the one end of the spectrum is a system like DART\cite{DART} that only reasons about concrete pointers, or systems like CUTE\cite{CUTE} and CREST\cite{CREST} that support only equality and inequality constraints for pointers, which can be efficiently solved.\cite{CUTE} At the other end are systems like EXE\cite{EXE}, and more recently KLEE\cite{KLEE} and SAGE\cite{SAGE} that model pointers using the theory of arrays with selections and updates implemented by solvers like STP or Z3.}\cite{ReviewThreeDecades}

\subsubsection{Handling Concurrency}
\begin{itemize}
    \item Testing usually difficult because of the inherent non-determinism.
    \item \textquote{Concolic testing was successfully combined with a variant of partial order reduction to test concurrent programs effectively.\cite{ScalableAutomatedMethods, OpenDistributedPrograms, ExplicitPathModelChecking,RaceDetection}}\cite{ReviewThreeDecades}
    \item \textquote{Generalized Symbolic Execution\cite{GSE} performs symbolic execution by leveraging an off-the-shelf model checker, whose built-in capabilities allow handling multi-threading (and other forms of non-determinism)}\cite{PreliminaryAssessment}
    \item \textquote{This method requires that a sequential version of the program be provided, to serve as the specification for the parallel one. The key idea is to use model checking, together with symbolic execution, to establish the equivalence of the two programs.}\cite{SPIN} (complex parallel numerical computations)
\end{itemize}

\subsubsection{Recursive Data Structures}
\begin{itemize}
    \item \textquote{GSE handles input recursive data structures by using lazy initialization. GSE starts execution of the method on inputs with uninitialized fields and non-deterministically initializes fields when they are first ac- cessed during the method's symbolic execution.}\cite{PreliminaryAssessment}
    \item \textquote{Pex\cite{Pex} supports the generation of test inputs of primitive types as well as (recursive) complex data types, for which Pex automatically computes a factory method which creates an instance of a complex data type by invoking a constructor and a sequence of methods, whose parameters are also determined by Pex.}\cite{PreliminaryAssessment}
\end{itemize}

\section{Improvements in Papers}
\todo{Filter for symbex}
\begin{itemize}
    \item Initial seed selection: up-front analysis\cite{Skyfire, Orthrus, DIFUZE}, grammar\cite{QuickFuzz, QuickFuzz2}
    \item Mutation: symbex to choose how many bits to flip\cite{SYMFUZZ}, taint analysis\cite{Mayhem, Angora, Steelix, VUzzer}, dynamic slicing\cite{MutaGen}, seed properties\cite{SDF}, grammars\cite{SCADA, IMF}, language constructs knowledge\cite{Chizpurfle}
    \item Eval: symbex when stuck\cite{Driller, Mayhem}, general symbex\cite{S2F}, speedup through OS optimizations\cite{OS} or other low-level primitives\cite{IMF, VDF, kAFL}, removing checks\cite{TFuzz}, fine-grained runtime analysis\cite{MEDS}
    \item Observation: longer running time\cite{SlowFuzz}, different behavior\cite{NEZHA}, additional instrumentation\cite{Steelix, Angora}, static analysis-guided searching\cite{Dowser, VUzzer}
    \item Seed selection: areas of interest reached\cite{AFLGo, CGF, FairFuzz, VUzzer}, different algorithm\cite{SeedSelection, Scheduling}
\end{itemize}

\section{Related Works and Methods}
\begin{itemize}
    \item Large scientific body of work
    \item Review papers
          \begin{itemize}
              \item Well cited
              \item New
              \item Specific topics to see if challenges and solutions differ
          \end{itemize}
\end{itemize}

\subsection{Survey Papers}
\subsubsection{General Survey Papers}
\begin{itemize}
    \item    All You Ever Wanted to Know about Dynamic Taint Analysis and Forward Symbolic Execution (but Might Have Been Afraid to Ask) (\citeyear{AllYouEverWanted})\cite{AllYouEverWanted}
    \item    Symbolic Execution for Software Testing in Practice – Preliminary Assessment (\citeyear{PreliminaryAssessment})\cite{PreliminaryAssessment}
    \item    Fuzzing: The State of the Art (\citeyear{FuzzingTheStateOfTheArt})\cite{FuzzingTheStateOfTheArt}
    \item    A systematic review of fuzzing techniques (\citeyear{Science})\cite{Science}
    \item    Fuzzing: A Survey (\citeyear{FuzzingASurvey})\cite{FuzzingASurvey}
    \item    Fuzzing: State of the Art (\citeyear{FuzzingStateOfTheArt2018})\cite{FuzzingStateOfTheArt2018}
    \item    Fuzzing: hack, art, and science (\citeyear{HackArtScience})\cite{HackArtScience}
    \item    A Systematic Review of Search Strategies in Dynamic Symbolic Execution (\citeyear{SearchStrategies})\cite{SearchStrategies}
    \item    Fuzzing: Challenges and Reflections (\citeyear{ChallengesAndReflections})\cite{ChallengesAndReflections}
    \item    Exploratory Review of Hybrid Fuzzing for Automated Vulnerability Detection (\citeyear{Hybrid})\cite{Hybrid}
    \item    The Art, Science, and Engineering of Fuzzing: A Survey (\citeyear{ArtScienceEngineeringFuzzing})\cite{ArtScienceEngineeringFuzzing}
    \item    Fuzzing: A Survey for Roadmap (\citeyear{FuzzingASurveyforRoadmap})\cite{FuzzingASurveyforRoadmap}
    \item    Fuzzing vulnerability discovery techniques: Survey, challenges and future directions (\citeyear{FuzzingVulnerabilityDiscoveryTechniques})\cite{FuzzingVulnerabilityDiscoveryTechniques}
    \item    Demystify the Fuzzing Methods: A Comprehensive Survey (\citeyear{Demystifying})\cite{Demystifying}
    \item    A systematic review of fuzzing (\citeyear{SystematicReview2023})\cite{SystematicReview2023}
\end{itemize}

\paragraph{Symbolic Execution for Software Testing in Practice – Preliminary Assessment (\citeyear{PreliminaryAssessment})}
After giving a short overview of issues faced by symbolic execution based fuzzers, this paper focuses on eight high impact fuzzing tools (JPF-SE and Symbolic (Java) PathFinder\cite{JPFSE, JavaPathFinder}, DART\cite{DART}, CUTE\cite{CUTE} and jCUTE\todo{CITE}, CREST\cite{CREST}, SAGE\cite{SAGE}, Pex\cite{Pex}, EXE\cite{EXE}, and KLEE\cite{KLEE}).

\paragraph{Symbolic Execution for Software Testing: Three Decades Later (\citeyear{ReviewThreeDecades})}
This survey paper, as the title suggests, focuses on symbolic execution. Starting with an explanation of classical symbolic execution, it then provides a list of issues that fuzzing tools based on symbolic execution face, along with attempts to mitigate those by adapting and extending the algorithms.\cite{ReviewThreeDecades}

\paragraph{Evaluating Fuzz Testing (\citeyear{ReviewThreeDecades})}
While not a classic survey paper, \textit{Evaluating Fuzz Testing} finds issues in how all 32 papers performed the evaluation of the system they introduced. It further proposes rules to follow to make an evaluation robust. Last, it contains a list of what advances each paper examined claims to introduce.\cite{EvaluatingFuzzTesting}


\subsubsection{Specific Survey Papers}
\begin{itemize}
    \item    Network protocol fuzz testing for information systems and applications: a survey and taxonomy (\citeyear{Network})\cite{Network}
    \item    A Survey of Dynamic Analysis and Test Generation for JavaScript (\citeyear{JavaScript2})\cite{JavaScript2}
    \item    Fuzzing the Internet of Things: A Review on the Techniques and Challenges for Efficient Vulnerability Discovery in Embedded Systems (\citeyear{IoT})\cite{IoT}
    \item    Firmware Fuzzing: The State of the Art (\citeyear{Firmware})\cite{Firmware}
    \item    Research on Fuzzing Technology for JavaScript Engines (\citeyear{JavaScript})\cite{JavaScript}
    \item    Ethereum Smart Contract Analysis Tools: A Systematic Review (\citeyear{Ethereum})\cite{Ethereum}
    \item    A Survey on the Development of Network Protocol Fuzzing Techniques (\citeyear{Network2023})\cite{Network2023}
    \item    Embedded fuzzing: a review of challenges, tools, and solutions (\citeyear{Embedded2})\cite{Embedded2}
    \item    Fuzzing of Embedded Systems: A Survey (\citeyear{Embedded})\cite{Embedded}
\end{itemize}

\section{Conclusions}

\subsection{Future Work}
\begin{itemize}
    \item Look at author overlap between the survey papers and influential primary papers to guide which review papers seem important (if you independently collect primary papers), if survey paper authors overemphasize their own contributions and maybe even miss other important developments
    \item History and composition of systems: Which influenced which, which builds on top of/extends which, etc.
\end{itemize}

\subsubsection{Bibliometry}


\pagebreak
\addcontentsline{toc}{section}{Bibliography}
\printbibliography[]

\end{document}
