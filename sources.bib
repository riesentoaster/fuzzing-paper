@article{UNIX,
  author     = {Miller, Barton P. and Fredriksen, Lars and So, Bryan},
  title      = {An Empirical Study of the Reliability of UNIX Utilities},
  year       = {1990},
  issue_date = {Dec. 1990},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {33},
  number     = {12},
  issn       = {0001-0782},
  url        = {https://doi.org/10.1145/96267.96279},
  doi        = {10.1145/96267.96279},
  abstract   = {The following section describes the tools we built to test the utilities. These tools include the fuzz (random character) generator, ptyjig (to test interactive utilities), and scripts to automate the testing process. Next, we will describe the tests we performed, giving the types of input we presented to the utilities. Results from the tests will follow along with an analysis of the results, including identification and classification of the program bugs that caused the crashes. The final section presents concluding remarks, including suggestions for avoiding the types of problems detected by our study and some commentary on the bugs we found. We include an Appendix with the user manual pages for fuzz and ptyjig.},
  journal    = {Commun. ACM},
  month      = {12},
  pages      = {32–44},
  numpages   = {13}
}

@inproceedings{DART,
  author    = {Godefroid, Patrice and Klarlund, Nils and Sen, Koushik},
  title     = {DART: Directed Automated Random Testing},
  year      = {2005},
  isbn      = {1595930566},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/1065010.1065036},
  doi       = {10.1145/1065010.1065036},
  abstract  = {We present a new tool, named DART, for automatically testing software that combines three main techniques: (1) automated extraction of the interface of a program with its external environment using static source-code parsing; (2) automatic generation of a test driver for this interface that performs random testing to simulate the most general environment the program can operate in; and (3) dynamic analysis of how the program behaves under random testing and automatic generation of new test inputs to direct systematically the execution along alternative program paths. Together, these three techniques constitute Directed Automated Random Testing, or DART for short. The main strength of DART is thus that testing can be performed completely automatically on any program that compiles -- there is no need to write any test driver or harness code. During testing, DART detects standard errors such as program crashes, assertion violations, and non-termination. Preliminary experiments to unit test several examples of C programs are very encouraging.},
  booktitle = {Proceedings of the 2005 ACM SIGPLAN Conference on Programming Language Design and Implementation},
  pages     = {213–223},
  numpages  = {11},
  keywords  = {software testing, interfaces, random testing, automated test generation, program verification},
  location  = {Chicago, IL, USA},
  series    = {PLDI '05}
}

@inproceedings{SAGE,
  title     = {Automated Whitebox Fuzz Testing},
  author    = {Patrice Godefroid and Michael Y. Levin and David A. Molnar},
  booktitle = {Network and Distributed System Security Symposium},
  year      = {2008},
  url       = {https://api.semanticscholar.org/CorpusID:1296783}
}

@inproceedings{GrammarBasedWhiteboxFuzzing,
  author    = {Godefroid, Patrice and Kiezun, Adam and Levin, Michael Y.},
  title     = {Grammar-Based Whitebox Fuzzing},
  year      = {2008},
  isbn      = {9781595938602},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/1375581.1375607},
  doi       = {10.1145/1375581.1375607},
  abstract  = {Whitebox fuzzing is a form of automatic dynamic test generation, based on symbolic execution and constraint solving, designed for security testing of large applications. Unfortunately, the current effectiveness of whitebox fuzzing is limited when testing applications with highly-structured inputs, such as compilers and interpreters. These applications process their inputs in stages, such as lexing, parsing and evaluation. Due to the enormous number of control paths in early processing stages, whitebox fuzzing rarely reaches parts of the application beyond those first stages.In this paper, we study how to enhance whitebox fuzzing of complex structured-input applications with a grammar-based specification of their valid inputs. We present a novel dynamic test generation algorithm where symbolic execution directly generates grammar-based constraints whose satisfiability is checked using a custom grammar-based constraint solver. We have implemented this algorithm and evaluated it on a large security-critical application, the JavaScript interpreter of Internet Explorer 7 (IE7). Results of our experiments show that grammar-based whitebox fuzzing explores deeper program paths and avoids dead-ends due to non-parsable inputs. Compared to regular whitebox fuzzing, grammar-based whitebox fuzzing increased coverage of the code generation module of the IE7 JavaScript interpreter from 53\% to 81\% while using three times fewer tests.},
  booktitle = {Proceedings of the 29th ACM SIGPLAN Conference on Programming Language Design and Implementation},
  pages     = {206–215},
  numpages  = {10},
  keywords  = {grammars, automatic test generation, software testing, program verification},
  location  = {Tucson, AZ, USA},
  series    = {PLDI '08}
}

@inproceedings{KLEE,
  author    = {Cadar, Cristian and Dunbar, Daniel and Engler, Dawson},
  title     = {KLEE: Unassisted and Automatic Generation of High-Coverage Tests for Complex Systems Programs},
  year      = {2008},
  publisher = {USENIX Association},
  address   = {USA},
  abstract  = {We present a new symbolic execution tool, KLEE, capable of automatically generating tests that achieve high coverage on a diverse set of complex and environmentally-intensive programs. We used KLEE to thoroughly check all 89 stand-alone programs in the GNU COREUTILS utility suite, which form the core user-level environment installed on millions of Unix systems, and arguably are the single most heavily tested set of open-source programs in existence. KLEE-generated tests achieve high line coverage -- on average over 90\% per tool (median: over 94\%) -- and significantly beat the coverage of the developers' own hand-written test suite. When we did the same for 75 equivalent tools in the BUSYBOX embedded system suite, results were even better, including 100\% coverage on 31 of them.We also used KLEE as a bug finding tool, applying it to 452 applications (over 430K total lines of code), where it found 56 serious bugs, including three in COREUTILS that had been missed for over 15 years. Finally, we used KLEE to crosscheck purportedly identical BUSYBOX and COREUTILS utilities, finding functional correctness errors and a myriad of inconsistencies.},
  booktitle = {Proceedings of the 8th USENIX Conference on Operating Systems Design and Implementation},
  pages     = {209–224},
  numpages  = {16},
  location  = {San Diego, California},
  series    = {OSDI'08}
}

@article{Science,
  title    = {A systematic review of fuzzing techniques},
  journal  = {Computers \& Security},
  volume   = {75},
  pages    = {118-137},
  year     = {2018},
  issn     = {0167-4048},
  doi      = {https://doi.org/10.1016/j.cose.2018.02.002},
  url      = {https://www.sciencedirect.com/science/article/pii/S0167404818300658},
  author   = {Chen Chen and Baojiang Cui and Jinxin Ma and Runpu Wu and Jianchao Guo and Wenqian Liu},
  keywords = {Software bug, Vulnerability, Fuzzing, Dynamic symbolic execution, Coverage guide, Grammar representation, Scheduling algorithms, Taint analysis, Static analysis},
  abstract = {Fuzzing is an effective and widely used technique for finding security bugs and vulnerabilities in software. It inputs irregular test data into a target program to try to trigger a vulnerable condition in the program execution. Since the first random fuzzing system was constructed, fuzzing efficiency has been greatly improved by combination with several useful techniques, including dynamic symbolic execution, coverage guide, grammar representation, scheduling algorithms, dynamic taint analysis, static analysis and machine learning. In this paper, we will systematically review these techniques and their corresponding representative fuzzing systems. By introducing the principles, advantages and disadvantages of these techniques, we hope to provide researchers with a systematic and deeper understanding of fuzzing techniques and provide some references for this field.}
}

@inproceedings{Driller,
  title     = {Driller: Augmenting Fuzzing Through Selective Symbolic Execution},
  author    = {Nick Stephens and John Grosen and Christopher Salls and Andrew Dutcher and Ruoyu Wang and Jacopo Corbetta and Yan Shoshitaishvili and Christopher Kr{\"u}gel and Giovanni Vigna},
  booktitle = {Network and Distributed System Security Symposium},
  year      = {2016},
  url       = {https://api.semanticscholar.org/CorpusID:2388545}
}

@inproceedings{AFLPlusPlus,
  author    = {Andrea Fioraldi and Dominik Maier and Heiko Ei{\ss}feldt and Marc Heuse},
  title     = {{AFL++} : Combining Incremental Steps of Fuzzing Research},
  booktitle = {14th USENIX Workshop on Offensive Technologies (WOOT 20)},
  year      = {2020},
  url       = {https://www.usenix.org/conference/woot20/presentation/fioraldi},
  publisher = {USENIX Association},
  month     = {08}
}

@inproceedings{AFLGo,
  author    = {B\"{o}hme, Marcel and Pham, Van-Thuan and Nguyen, Manh-Dung and Roychoudhury, Abhik},
  title     = {Directed Greybox Fuzzing},
  year      = {2017},
  isbn      = {9781450349468},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/3133956.3134020},
  doi       = {10.1145/3133956.3134020},
  abstract  = {Existing Greybox Fuzzers (GF) cannot be effectively directed, for instance, towards problematic changes or patches, towards critical system calls or dangerous locations, or towards functions in the stack-trace of a reported vulnerability that we wish to reproduce. In this paper, we introduce Directed Greybox Fuzzing (DGF) which generates inputs with the objective of reaching a given set of target program locations efficiently. We develop and evaluate a simulated annealing-based power schedule that gradually assigns more energy to seeds that are closer to the target locations while reducing energy for seeds that are further away. Experiments with our implementation AFLGo demonstrate that DGF outperforms both directed symbolic-execution-based whitebox fuzzing and undirected greybox fuzzing. We show applications of DGF to patch testing and crash reproduction, and discuss the integration of AFLGo into Google's continuous fuzzing platform OSS-Fuzz. Due to its directedness, AFLGo could find 39 bugs in several well-fuzzed, security-critical projects like LibXML2. 17 CVEs were assigned.},
  booktitle = {Proceedings of the 2017 ACM SIGSAC Conference on Computer and Communications Security},
  pages     = {2329–2344},
  numpages  = {16},
  keywords  = {reachability, directed testing, coverage-based greybox fuzzing, verifying true positives, patch testing, crash reproduction},
  location  = {Dallas, Texas, USA},
  series    = {CCS '17}
}
@inproceedings{Munch,
  author    = {Ognawala, Saahil and Hutzelmann, Thomas and Psallida, Eirini and Pretschner, Alexander},
  title     = {Improving Function Coverage with Munch: A Hybrid Fuzzing and Directed Symbolic Execution Approach},
  year      = {2018},
  isbn      = {9781450351911},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/3167132.3167289},
  doi       = {10.1145/3167132.3167289},
  abstract  = {Fuzzing and symbolic execution are popular techniques for finding vulnerabilities and generating test-cases for programs. Fuzzing, a blackbox method that mutates seed input values, is generally incapable of generating diverse inputs that exercise all paths in the program. Due to the path-explosion problem and dependence on SMT solvers, symbolic execution may also not achieve high path coverage. A hybrid technique involving fuzzing and symbolic execution may achieve better function coverage than fuzzing or symbolic execution alone. In this paper, we present Munch, an open-source framework implementing two hybrid techniques based on fuzzing and symbolic execution. We empirically show using nine large open-source programs that overall, Munch achieves higher (in-depth) function coverage than symbolic execution or fuzzing alone. Using metrics based on total analyses time and number of queries issued to the SMT solver, we also show that Munch is more efficient at achieving better function coverage.},
  booktitle = {Proceedings of the 33rd Annual ACM Symposium on Applied Computing},
  pages     = {1475–1482},
  numpages  = {8},
  keywords  = {symbolic execution, function coverage, compositional analysis, software testing, fuzzing},
  location  = {Pau, France},
  series    = {SAC '18}
}

@article{Magma,
  author     = {Hazimeh, Ahmad and Herrera, Adrian and Payer, Mathias},
  title      = {Magma: A Ground-Truth Fuzzing Benchmark},
  year       = {2021},
  issue_date = {December 2020},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {4},
  number     = {3},
  url        = {https://doi.org/10.1145/3428334},
  doi        = {10.1145/3428334},
  abstract   = {High scalability and low running costs have made fuzz testing the de facto standard for discovering software bugs. Fuzzing techniques are constantly being improved in a race to build the ultimate bug-finding tool. However, while fuzzing excels at finding bugs in the wild, evaluating and comparing fuzzer performance is challenging due to the lack of metrics and benchmarks. For example, crash count---perhaps the most commonly-used performance metric---is inaccurate due to imperfections in deduplication techniques. Additionally, the lack of a unified set of targets results in ad hoc evaluations that hinder fair comparison. We tackle these problems by developing Magma, a ground-truth fuzzing benchmark that enables uniform fuzzer evaluation and comparison. By introducing real bugs into real software, Magma allows for the realistic evaluation of fuzzers against a broad set of targets. By instrumenting these bugs, Magma also enables the collection of bug-centric performance metrics independent of the fuzzer. Magma is an open benchmark consisting of seven targets that perform a variety of input manipulations and complex computations, presenting a challenge to state-of-the-art fuzzers. We evaluate seven widely-used mutation-based fuzzers (AFL, AFLFast, AFL++, FairFuzz, MOpt-AFL, honggfuzz, and SymCC-AFL) against Magma over 200,000 CPU-hours. Based on the number of bugs reached, triggered, and detected, we draw conclusions about the fuzzers' exploration and detection capabilities. This provides insight into fuzzer performance evaluation, highlighting the importance of ground truth in performing more accurate and meaningful evaluations.},
  journal    = {Proc. ACM Meas. Anal. Comput. Syst.},
  month      = {06},
  articleno  = {49},
  numpages   = {29},
  keywords   = {benchmark, fuzzing, performance evaluation, software security}
}

@inproceedings{TFuzz,
  author    = {Peng, Hui and Shoshitaishvili, Yan and Payer, Mathias},
  booktitle = {2018 IEEE Symposium on Security and Privacy (SP)},
  title     = {T-Fuzz: Fuzzing by Program Transformation},
  year      = {2018},
  volume    = {},
  number    = {},
  pages     = {697-710},
  doi       = {10.1109/SP.2018.00056}
}

@inproceedings{LearnFuzz,
  author    = {Godefroid, Patrice and Peleg, Hila and Singh, Rishabh},
  booktitle = {2017 32nd IEEE/ACM International Conference on Automated Software Engineering (ASE)},
  title     = {Learn\&Fuzz: Machine learning for input fuzzing},
  year      = {2017},
  volume    = {},
  number    = {},
  pages     = {50-59},
  doi       = {10.1109/ASE.2017.8115618}
}

@article{FuzzingASurvey,
  title   = {Fuzzing: a survey},
  author  = {Jun Li and Bodong Zhao and Chao Zhang},
  journal = {Cybersecurity},
  year    = {2018},
  volume  = {1},
  pages   = {1-13},
  url     = {https://api.semanticscholar.org/CorpusID:46928493}
}

@article{FuzzingASurveyforRoadmap,
  author     = {Zhu, Xiaogang and Wen, Sheng and Camtepe, Seyit and Xiang, Yang},
  title      = {Fuzzing: A Survey for Roadmap},
  year       = {2022},
  issue_date = {January 2022},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {54},
  number     = {11s},
  issn       = {0360-0300},
  url        = {https://doi.org/10.1145/3512345},
  doi        = {10.1145/3512345},
  abstract   = {Fuzz testing (fuzzing) has witnessed its prosperity in detecting security flaws recently. It generates a large number of test cases and monitors the executions for defects. Fuzzing has detected thousands of bugs and vulnerabilities in various applications. Although effective, there lacks systematic analysis of gaps faced by fuzzing. As a technique of defect detection, fuzzing is required to narrow down the gaps between the entire input space and the defect space. Without limitation on the generated inputs, the input space is infinite. However, defects are sparse in an application, which indicates that the defect space is much smaller than the entire input space. Besides, because fuzzing generates numerous test cases to repeatedly examine targets, it requires fuzzing to perform in an automatic manner. Due to the complexity of applications and defects, it is challenging to automatize the execution of diverse applications. In this article, we systematically review and analyze the gaps as well as their solutions, considering both breadth and depth. This survey can be a roadmap for both beginners and advanced developers to better understand fuzzing.},
  journal    = {ACM Comput. Surv.},
  month      = {09},
  articleno  = {230},
  numpages   = {36},
  keywords   = {fuzzing theory, security, input space, Fuzz testing, automation}
}

@article{ArtScienceEng,
  author  = {Manès, Valentin J.M. and Han, HyungSeok and Han, Choongwoo and Cha, Sang Kil and Egele, Manuel and Schwartz, Edward J. and Woo, Maverick},
  journal = {IEEE Transactions on Software Engineering},
  title   = {The Art, Science, and Engineering of Fuzzing: A Survey},
  year    = {2021},
  volume  = {47},
  number  = {11},
  pages   = {2312-2331},
  doi     = {10.1109/TSE.2019.2946563}
}

@article{Demystifying,
  author     = {Mallissery, Sanoop and Wu, Yu-Sung},
  title      = {Demystify the Fuzzing Methods: A Comprehensive Survey},
  year       = {2023},
  issue_date = {March 2024},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {56},
  number     = {3},
  issn       = {0360-0300},
  url        = {https://doi.org/10.1145/3623375},
  doi        = {10.1145/3623375},
  abstract   = {Massive software applications possess complex data structures or parse complex data structures; in such cases, vulnerabilities in the software become inevitable. The vulnerabilities are the source of cyber-security threats, and discovering this before the software deployment is challenging. Fuzzing is a vulnerability discovery solution that resonates with random-mutation, feedback-driven, coverage-guided, constraint-guided, seed-scheduling, and target-oriented strategies. Each technique is wrapped beneath the black-, white-, and grey-box fuzzers to uncover diverse vulnerabilities. It consists of methods such as identifying structural information about the test cases to detect security vulnerabilities, symbolic and concrete program states to explore the unexplored locations, and full semantics of code coverage to create new test cases. We methodically examine each kind of fuzzers and contemporary fuzzers with a profound observation that addresses various research questions and systematically reviews and analyze the gaps and their solutions. Our survey comprised the recent related works on fuzzing techniques to demystify the fuzzing methods concerning the application domains and the target that, in turn, achieves higher code coverage and sound vulnerability detection.},
  journal    = {ACM Comput. Surv.},
  month      = {10},
  articleno  = {71},
  numpages   = {38},
  keywords   = {vulnerability discovery, Automated testing, fuzzing, code inspection}
}

@article{FuzzingVulnerabilityDiscoveryTechniques,
  title    = {Fuzzing vulnerability discovery techniques: Survey, challenges and future directions},
  journal  = {Computers \& Security},
  volume   = {120},
  pages    = {102813},
  year     = {2022},
  issn     = {0167-4048},
  doi      = {https://doi.org/10.1016/j.cose.2022.102813},
  url      = {https://www.sciencedirect.com/science/article/pii/S0167404822002073},
  author   = {Craig Beaman and Michael Redbourne and J. Darren Mummery and Saqib Hakak},
  keywords = {Vulnerability, Fuzzing, Software Security, Fuzzers, Software Vulnerability, Vulnerability accessment, Static code analysis, Security},
  abstract = {Fuzzing is a powerful tool for vulnerability discovery in software, with much progress being made in the field in recent years. There is limited literature available on the fuzzing vulnerability discovery approaches. Hence, in this paper, an attempt has been made to explore the recent advances in the area of fuzzing vulnerability discovery and to propose a refinement to the classification of fuzzers. Furthermore, we have identified key research challenges and potential future areas of research that might provide new insight to researchers.}
}

@inproceedings{TaintScope,
  author    = {Wang, Tielei and Wei, Tao and Gu, Guofei and Zou, Wei},
  booktitle = {2010 IEEE Symposium on Security and Privacy},
  title     = {TaintScope: A Checksum-Aware Directed Fuzzing Tool for Automatic Software Vulnerability Detection},
  year      = {2010},
  volume    = {},
  number    = {},
  pages     = {497-512},
  doi       = {10.1109/SP.2010.37}
}

@article{ReviewThreeDecades,
  author     = {Cadar, Cristian and Sen, Koushik},
  title      = {Symbolic Execution for Software Testing: Three Decades Later},
  year       = {2013},
  issue_date = {February 2013},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {56},
  number     = {2},
  issn       = {0001-0782},
  url        = {https://doi.org/10.1145/2408776.2408795},
  doi        = {10.1145/2408776.2408795},
  abstract   = {The challenges---and great promise---of modern symbolic execution techniques, and the tools to help implement them.},
  journal    = {Commun. ACM},
  month      = {02},
  pages      = {82–90},
  numpages   = {9}
}

@article{CUTE,
  author     = {Sen, Koushik and Marinov, Darko and Agha, Gul},
  title      = {CUTE: A Concolic Unit Testing Engine for C},
  year       = {2005},
  issue_date = {September 2005},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {30},
  number     = {5},
  issn       = {0163-5948},
  url        = {https://doi.org/10.1145/1095430.1081750},
  doi        = {10.1145/1095430.1081750},
  abstract   = {In unit testing, a program is decomposed into units which are collections of functions. A part of unit can be tested by generating inputs for a single entry function. The entry function may contain pointer arguments, in which case the inputs to the unit are memory graphs. The paper addresses the problem of automating unit testing with memory graphs as inputs. The approach used builds on previous work combining symbolic and concrete execution, and more specifically, using such a combination to generate test inputs to explore all feasible execution paths. The current work develops a method to represent and track constraints that capture the behavior of a symbolic execution of a unit with memory graphs as inputs. Moreover, an efficient constraint solver is proposed to facilitate incremental generation of such test inputs. Finally, CUTE, a tool implementing the method is described together with the results of applying CUTE to real-world examples of C code.},
  journal    = {SIGSOFT Softw. Eng. Notes},
  month      = {09},
  pages      = {263–272},
  numpages   = {10},
  keywords   = {concolic testing, unit testing, random testing, testing C programs, data structure testing, explicit path model-checking}
}

@inproceedings{BuzzFuzz,
  author    = {Ganesh, Vijay and Leek, Tim and Rinard, Martin},
  booktitle = {2009 IEEE 31st International Conference on Software Engineering},
  title     = {Taint-based directed whitebox fuzzing},
  year      = {2009},
  volume    = {},
  number    = {},
  pages     = {474-484},
  doi       = {10.1109/ICSE.2009.5070546}
}

@article{SAGEImpact,
  author     = {Godefroid, Patrice and Levin, Michael Y. and Molnar, David},
  title      = {SAGE: Whitebox Fuzzing for Security Testing: SAGE Has Had a Remarkable Impact at Microsoft.},
  year       = {2012},
  issue_date = {January 2012},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {10},
  number     = {1},
  issn       = {1542-7730},
  url        = {https://doi.org/10.1145/2090147.2094081},
  doi        = {10.1145/2090147.2094081},
  abstract   = {Most ACM Queue readers might think of "program verification research" as mostly theoretical with little impact on the world at large. Think again. If you are reading these lines on a PC running some form of Windows (like 93-plus percent of PC users--that is, more than a billion people), then you have been affected by this line of work--without knowing it, which is precisely the way we want it to be.},
  journal    = {Queue},
  month      = {01},
  pages      = {20–27},
  numpages   = {8}
}

@article{DowserArticle,
  title   = {Dowser: A Guided Fuzzer for Finding Buffer Overflow Vulnerabilities},
  author  = {Istv{\'a}n Haller and Asia Slowinska and Matthias Neugschwandtner and Herbert Bos},
  journal = {login Usenix Mag.},
  year    = {2013},
  volume  = {38},
  url     = {https://api.semanticscholar.org/CorpusID:56594822}
}

@inproceedings{Dowser,
  author    = {Haller, Istvan and Slowinska, Asia and Neugschwandtner, Matthias and Bos, Herbert},
  title     = {Dowsing for Overflows: A Guided Fuzzer to Find Buffer Boundary Violations},
  year      = {2013},
  isbn      = {9781931971034},
  publisher = {USENIX Association},
  address   = {USA},
  abstract  = {Dowser is a 'guided' fuzzer that combines taint tracking, program analysis and symbolic execution to find buffer overflow and underflow vulnerabilities buried deep in a program's logic. The key idea is that analysis of a program lets us pinpoint the right areas in the program code to probe and the appropriate inputs to do so.Intuitively, for typical buffer overflows, we need consider only the code that accesses an array in a loop, rather than all possible instructions in the program. After finding all such candidate sets of instructions, we rank them according to an estimation of how likely they are to contain interesting vulnerabilities. We then subject the most promising sets to further testing. Specifically, we first use taint analysis to determine which input bytes influence the array index and then execute the program symbolically, making only this set of inputs symbolic. By constantly steering the symbolic execution along branch outcomes most likely to lead to overflows, we were able to detect deep bugs in real programs (like the nginx webserver, the inspircd IRC server, and the ffmpeg videoplayer). Two of the bugs we found were previously undocumented buffer overflows in ffmpeg and the poppler PDF rendering library.},
  booktitle = {Proceedings of the 22nd USENIX Conference on Security},
  pages     = {49–64},
  numpages  = {16},
  location  = {Washington, D.C.},
  series    = {SEC'13}
}

@inproceedings{BORG,
  author    = {Neugschwandtner, Matthias and Milani Comparetti, Paolo and Haller, Istvan and Bos, Herbert},
  title     = {The BORG: Nanoprobing Binaries for Buffer Overreads},
  year      = {2015},
  isbn      = {9781450331913},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/2699026.2699098},
  doi       = {10.1145/2699026.2699098},
  abstract  = {Automated program testing tools typically try to explore, and cover, as much of a tested program as possible, while attempting to trigger and detect bugs. An alternative and complementary approach can be to first select a specific part of a program that may be subject to a specific class of bug, and then narrowly focus exploration towards program paths that could trigger such a bug.In this work, we introduce the BORG (Buffer Over-Read Guard), a testing tool that uses static and dynamic program analysis, taint propagation and symbolic execution to detect buffer overread bugs in real-world programs. BORG works by first selecting buffer accesses that could lead to an overread and then guiding symbolic execution towards those accesses along program paths that could actually lead to an overread. BORG operates on binaries and does not require source code. To demonstrate BORG's effectiveness, we use it to detect overreads in six complex server applications and libraries, including lighttpd, FFmpeg and ClamAV.},
  booktitle = {Proceedings of the 5th ACM Conference on Data and Application Security and Privacy},
  pages     = {87–97},
  numpages  = {11},
  keywords  = {out-of-bounds access, symbolic execution guidance, dynamic symbolic execution, buffer overread, targeted testing},
  location  = {San Antonio, Texas, USA},
  series    = {CODASPY '15}
}

@inproceedings{MoWF,
  author    = {Pham, Van-Thuan and B\"{o}hme, Marcel and Roychoudhury, Abhik},
  title     = {Model-Based Whitebox Fuzzing for Program Binaries},
  year      = {2016},
  isbn      = {9781450338455},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/2970276.2970316},
  doi       = {10.1145/2970276.2970316},
  abstract  = {Many real-world programs take highly structured and very complex inputs. The automated testing of such programs is non-trivial. If the test input does not adhere to a specific file format, the program returns a parser error. For symbolic execution-based whitebox fuzzing the corresponding error handling code becomes a significant time sink. Too much time is spent in the parser exploring too many paths leading to trivial parser errors. Naturally, the time is better spent exploring the functional part of the program where failure with valid input exposes deep and real bugs in the program. In this paper, we suggest to leverage information about the file format and the data chunks of existing, valid files to swiftly carry the exploration beyond the parser code. We call our approach Model-based Whitebox Fuzzing (MoWF) because the file format input model of blackbox fuzzers can be exploited as a constraint on the vast input space to rule out most invalid inputs during path exploration in symbolic execution. We evaluate on 13 vulnerabilities in 8 large program binaries with 6 separate file formats and found that MoWF exposes all vulnerabilities while both, traditional whitebox fuzzing and model-based blackbox fuzzing, expose only less than half, respectively. Our experiments also demonstrate that MoWF exposes 70\% vulnerabilities without any seed inputs.},
  booktitle = {Proceedings of the 31st IEEE/ACM International Conference on Automated Software Engineering},
  pages     = {543–553},
  numpages  = {11},
  keywords  = {Symbolic Execution, Program Binaries},
  location  = {Singapore, Singapore},
  series    = {ASE '16}
}

@article{S2E,
  author     = {Chipounov, Vitaly and Kuznetsov, Volodymyr and Candea, George},
  title      = {S2E: A Platform for in-Vivo Multi-Path Analysis of Software Systems},
  year       = {2011},
  issue_date = {March 2011},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {46},
  number     = {3},
  issn       = {0362-1340},
  url        = {https://doi.org/10.1145/1961296.1950396},
  doi        = {10.1145/1961296.1950396},
  abstract   = {This paper presents S2E, a platform for analyzing the properties and behavior of software systems. We demonstrate S2E's use in developing practical tools for comprehensive performance profiling, reverse engineering of proprietary software, and bug finding for both kernel-mode and user-mode binaries. Building these tools on top of S2E took less than 770 LOC and 40 person-hours each.S2E's novelty consists of its ability to scale to large real systems, such as a full Windows stack. S2E is based on two new ideas: selective symbolic execution, a way to automatically minimize the amount of code that has to be executed symbolically given a target analysis, and relaxed execution consistency models, a way to make principled performance/accuracy trade-offs in complex analyses. These techniques give S2E three key abilities: to simultaneously analyze entire families of execution paths, instead of just one execution at a time; to perform the analyses in-vivo within a real software stack--user programs, libraries, kernel, drivers, etc.--instead of using abstract models of these layers; and to operate directly on binaries, thus being able to analyze even proprietary software.Conceptually, S2E is an automated path explorer with modular path analyzers: the explorer drives the target system down all execution paths of interest, while analyzers check properties of each such path (e.g., to look for bugs) or simply collect information (e.g., count page faults). Desired paths can be specified in multiple ways, and S2E users can either combine existing analyzers to build a custom analysis tool, or write new analyzers using the S2E API.},
  journal    = {SIGPLAN Not.},
  month      = {03},
  pages      = {265–278},
  numpages   = {14},
  keywords   = {dbt, virtualization, consistency models, testing, symbolic execution, binary, analysis, performance, in-vivo, framework}
}

@inproceedings{Mayhem,
  author    = {Cha, Sang Kil and Avgerinos, Thanassis and Rebert, Alexandre and Brumley, David},
  booktitle = {2012 IEEE Symposium on Security and Privacy},
  title     = {Unleashing Mayhem on Binary Code},
  year      = {2012},
  volume    = {},
  number    = {},
  pages     = {380-394},
  doi       = {10.1109/SP.2012.31}
}

@inproceedings{VUzzer,
  title     = {VUzzer: Application-aware Evolutionary Fuzzing},
  author    = {Sanjay Rawat and Vivek Jain and Ashish Kumar and Lucian Cojocar and Cristiano Giuffrida and Herbert Bos},
  booktitle = {Network and Distributed System Security Symposium},
  year      = {2017},
  url       = {https://api.semanticscholar.org/CorpusID:2354736}
}

@inproceedings{SYMFUZZ,
  author    = {Cha, Sang Kil and Woo, Maverick and Brumley, David},
  booktitle = {2015 IEEE Symposium on Security and Privacy},
  title     = {Program-Adaptive Mutational Fuzzing},
  year      = {2015},
  volume    = {},
  number    = {},
  pages     = {725-741},
  doi       = {10.1109/SP.2015.50}
}

@inproceedings{EvaluatingFuzzTesting,
  author    = {Klees, George and Ruef, Andrew and Cooper, Benji and Wei, Shiyi and Hicks, Michael},
  title     = {Evaluating Fuzz Testing},
  year      = {2018},
  isbn      = {9781450356930},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/3243734.3243804},
  doi       = {10.1145/3243734.3243804},
  abstract  = {Fuzz testing has enjoyed great success at discovering security critical bugs in real software. Recently, researchers have devoted significant effort to devising new fuzzing techniques, strategies, and algorithms. Such new ideas are primarily evaluated experimentally so an important question is: What experimental setup is needed to produce trustworthy results? We surveyed the recent research literature and assessed the experimental evaluations carried out by 32 fuzzing papers. We found problems in every evaluation we considered. We then performed our own extensive experimental evaluation using an existing fuzzer. Our results showed that the general problems we found in existing experimental evaluations can indeed translate to actual wrong or misleading assessments. We conclude with some guidelines that we hope will help improve experimental evaluations of fuzz testing algorithms, making reported results more robust.},
  booktitle = {Proceedings of the 2018 ACM SIGSAC Conference on Computer and Communications Security},
  pages     = {2123–2138},
  numpages  = {16},
  keywords  = {fuzzing, evaluation, security},
  location  = {Toronto, Canada},
  series    = {CCS '18}
}

@article{HackArtScience,
  author     = {Godefroid, Patrice},
  title      = {Fuzzing: Hack, Art, and Science},
  year       = {2020},
  issue_date = {February 2020},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {63},
  number     = {2},
  issn       = {0001-0782},
  url        = {https://doi.org/10.1145/3363824},
  doi        = {10.1145/3363824},
  abstract   = {Reviewing software testing techniques for finding security vulnerabilities.},
  journal    = {Commun. ACM},
  month      = {01},
  pages      = {70–76},
  numpages   = {7}
}

@article{FuzzingTheStateOfTheArt,
  title   = {Fuzzing: The State of the Art},
  journal = {DSTO Defence Science and Technology Organisation},
  author  = {Richard McNally and Kenneth Kwok-Hei Yiu and Duncan A. Grove and Damien Gerhardy},
  year    = {2012},
  url     = {https://api.semanticscholar.org/CorpusID:15447929}
}

@article{SystematicReview2023,
  title     = {A systematic review of fuzzing},
  author    = {Zhao, Xiaoqi and Qu, Haipeng and Xu, Jianliang and Li, Xiaohui and Lv, Wenjie and Wang, Gai-Ge},
  journal   = {Soft Computing},
  pages     = {1--30},
  year      = {2023},
  publisher = {Springer}
}

@article{IoT,
  author  = {Eceiza, Maialen and Flores, Jose Luis and Iturbe, Mikel},
  journal = {IEEE Internet of Things Journal},
  title   = {Fuzzing the Internet of Things: A Review on the Techniques and Challenges for Efficient Vulnerability Discovery in Embedded Systems},
  year    = {2021},
  volume  = {8},
  number  = {13},
  pages   = {10390-10411},
  doi     = {10.1109/JIOT.2021.3056179}
}

@article{ChallengesAndReflections,
  author  = {Boehme, Marcel and Cadar, Cristian and ROYCHOUDHURY, Abhik},
  journal = {IEEE Software},
  title   = {Fuzzing: Challenges and Reflections},
  year    = {2021},
  volume  = {38},
  number  = {3},
  pages   = {79-86},
  doi     = {10.1109/MS.2020.3016773}
}

@article{Network,
  author   = {Munea, Tewodros Legesse and Lim, Hyunwoo and Shon, Taeshik},
  title    = {Network protocol fuzz testing for information systems and applications: a survey and taxonomy},
  journal  = {Multimedia Tools and Applications},
  year     = {2016},
  month    = {11},
  day      = {01},
  volume   = {75},
  number   = {22},
  pages    = {14745-14757},
  abstract = {Fuzzing or fuzz testing has been introduced as a software testing technique to reduce vulnerabilities in software systems or given targets. To achieve a maximum benefit-to-cost ratio and without complication, we use fuzz testing [11]. In addition, during the development and debugging of a system, we may fail to notice the kinds of shortcoming that fuzz testing can expose. Fuzz testing types are different depending on the target they fuzz. Application, file format, and protocol fuzzing are the most common fuzzing types. A protocol fuzzer sends counterfeit packets to a target system while changing the normal packet en-route and sometimes replaying them. In addition, a protocol fuzzer sometimes acts as proxy server for clients. This survey study examines network protocol fuzz testing. We identified several studies on network protocol fuzzing. Most focus on application layers of the Open Systems Interconnection model. We primarily review the approaches of five studies and the targets and protocol layers they fuzz. We then develop criteria to compare these approaches in detail.},
  issn     = {1573-7721},
  doi      = {10.1007/s11042-015-2763-6},
  url      = {https://doi.org/10.1007/s11042-015-2763-6}
}

@article{FuzzingStateOfTheArt2018,
  author  = {Liang, Hongliang and Pei, Xiaoxiao and Jia, Xiaodong and Shen, Wuwei and Zhang, Jian},
  journal = {IEEE Transactions on Reliability},
  title   = {Fuzzing: State of the Art},
  year    = {2018},
  volume  = {67},
  number  = {3},
  pages   = {1199-1218},
  doi     = {10.1109/TR.2018.2834476}
}

@inproceedings{Firmware,
  author    = {Zhang, Chi and Wang, Yu and Wang, Linzhang},
  title     = {Firmware Fuzzing: The State of the Art},
  year      = {2021},
  isbn      = {9781450388191},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/3457913.3457934},
  doi       = {10.1145/3457913.3457934},
  abstract  = {Background: Firmware is the enable software of Internet of Things (IoT) devices, and its software vulnerabilities are one of the primary reason of IoT devices being exploited. Due to the limited resources of IoT devices, it is impractical to deploy sophisticated run-time protection techniques. Under an insecure network environment, when a firmware is exploited, it may lead to denial of service, information disclosure, elevation of privilege, or even life-threatening. Therefore, firmware vulnerability detection by fuzzing has become the key to ensure the security of IoT devices, and has also become a hot topic in academic and industrial research. With the rapid growth of the existing IoT devices, the size and complexity of firmware, the variety of firmware types, and the firmware defects, existing IoT firmware fuzzing methods face challenges. Objective: This paper summarizes the typical types of IoT firmware fuzzing methods, analyzes the contribution of these works, and summarizes the shortcomings of existing fuzzing methods. Method: We design several research questions, extract keywords from the research questions, then use the keywords to search for related literature. Result: We divide the existing firmware fuzzing work into real-device-based fuzzing and simulation-based fuzzing according to the firmware execution environment, and simulation-based fuzzing is the mainstream in the future; we found that the main types of vulnerabilities targeted by existing fuzzing methods are memory corruption vulnerabilities; firmware fuzzing faces more difficulties than ordinary software fuzzing. Conclusion: Through the analysis of the advantages and disadvantages of different methods, this review provides guidance for further improving the performance of fuzzing techniques, and proposes several recommendations from the findings of this review.},
  booktitle = {Proceedings of the 12th Asia-Pacific Symposium on Internetware},
  pages     = {110–115},
  numpages  = {6},
  keywords  = {literature review, firmware, Internet of Things, fuzzing},
  location  = {Singapore, Singapore},
  series    = {Internetware '20}
}

@article{Embedded,
  author     = {Yun, Joobeom and Rustamov, Fayozbek and Kim, Juhwan and Shin, Youngjoo},
  title      = {Fuzzing of Embedded Systems: A Survey},
  year       = {2022},
  issue_date = {July 2023},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {55},
  number     = {7},
  issn       = {0360-0300},
  url        = {https://doi.org/10.1145/3538644},
  doi        = {10.1145/3538644},
  abstract   = {Security attacks abuse software vulnerabilities of IoT devices; hence, detecting and eliminating these vulnerabilities immediately are crucial. Fuzzing is an efficient method to identify vulnerabilities automatically, and many publications have been released to date. However, fuzzing for embedded systems has not been studied extensively owing to various obstacles, such as multi-architecture support, crash detection difficulties, and limited resources. Thus, the article introduces fuzzing techniques for embedded systems and the fuzzing differences for desktop and embedded systems. Further, we collect state-of-the-art technologies, discuss their advantages and disadvantages, and classify embedded system fuzzing tools. Finally, future directions for fuzzing research of embedded systems are predicted and discussed.},
  journal    = {ACM Comput. Surv.},
  month      = {12},
  articleno  = {137},
  numpages   = {33},
  keywords   = {embedded systems, fuzzing, software testing, Firmware fuzzing, symbolic execution, concolic execution, IoT devices, firmware analysis}
}

@inproceedings{JavaScript,
  author    = {Tian, Ye and Qin, Xiaojun and Gan, Shuitao},
  title     = {Research on Fuzzing Technology for JavaScript Engines},
  year      = {2021},
  isbn      = {9781450389853},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/3487075.3487107},
  doi       = {10.1145/3487075.3487107},
  abstract  = {JavaScript engine is the core component of web browsers, whose security issues are one of the critical aspects of the overall Web Eco-Security. Fuzzing technology, as an efficient software testing approach, has been widely applied to detecting vulnerabilities in different JavaScript engines, which is a security research hotspot at present. Based on systematical dissection of existing fuzzing methods, this paper reviews the development and technical ideas of JavaScript Engine Fuzzing combined with taxonomy, proposes a general framework of JavaScript Engine Fuzzing and analyzes the key techniques involved. Finally, we discuss the core issues that restrict efficiency in current research and present an outlook on the future trends of JavaScript Engine Fuzzing.},
  booktitle = {Proceedings of the 5th International Conference on Computer Science and Application Engineering},
  articleno = {32},
  numpages  = {7},
  keywords  = {Fuzzing, Browser security, JavaScript engine, Vulnerability detection},
  location  = {Sanya, China},
  series    = {CSAE '21}
}
@article{SearchStrategies,
  title    = {A Systematic Review of Search Strategies in Dynamic Symbolic Execution},
  journal  = {Computer Standards \& Interfaces},
  volume   = {72},
  pages    = {103444},
  year     = {2020},
  issn     = {0920-5489},
  doi      = {https://doi.org/10.1016/j.csi.2020.103444},
  url      = {https://www.sciencedirect.com/science/article/pii/S0920548919300066},
  author   = {Arash Sabbaghi and Mohammad Reza Keyvanpour},
  keywords = {Software Quality, Software Testing, Dynamic Symbolic Execution, Concolic Testing, Execution Generated Testing, Search Strategy},
  abstract = {One of the major concerns of dynamic symbolic execution (DSE) based automated test case generation is its huge search space which restricts its usage for industrial-size program testing. In fact, DSE performs test case generation by exploring paths of the program, and the number of program paths is exponential in the number of branch conditions encountered during execution. Thus, by increasing the number of branches, the search space will be extremely large and without applying an effective and efficient technique to explore the search space, DSE would fail to achieve the predesignated goals in the given budget. To this end, different search strategies have been proposed to prioritize program paths and to select the most promising ones with respect to the testing goal. In this paper, we conduct a comprehensive systematic review of search strategies in DSE. We collect different techniques and methods concerning the topic, classify and summarize them, highlight their advantages and drawbacks, and provide a complete comparison of the methods in each category. The classification is carried out according to the type of search and also the information source exploited by the strategies to direct DSE. We also analyze the evaluation methodologies of experiments reported on this subject, give a general overview of them, perform a set of experiments and provide a set of guidelines for conducting future experiments in this area of research.}
}

@inproceedings{PreliminaryAssessment,
  author    = {Cadar, Cristian and Godefroid, Patrice and Khurshid, Sarfraz and P\u{a}s\u{a}reanu, Corina S. and Sen, Koushik and Tillmann, Nikolai and Visser, Willem},
  title     = {Symbolic Execution for Software Testing in Practice: Preliminary Assessment},
  year      = {2011},
  isbn      = {9781450304450},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/1985793.1985995},
  doi       = {10.1145/1985793.1985995},
  abstract  = {We present results for the "Impact Project Focus Area" on the topic of symbolic execution as used in software testing. Symbolic execution is a program analysis technique introduced in the 70s that has received renewed interest in recent years, due to algorithmic advances and increased availability of computational power and constraint solving technology. We review classical symbolic execution and some modern extensions such as generalized symbolic execution and dynamic test generation. We also give a preliminary assessment of the use in academia, research labs, and industry.},
  booktitle = {Proceedings of the 33rd International Conference on Software Engineering},
  pages     = {1066–1071},
  numpages  = {6},
  keywords  = {generalized symbolic execution, dynamic test generation},
  location  = {Waikiki, Honolulu, HI, USA},
  series    = {ICSE '11}
}

@article{EXE,
  author     = {Cadar, Cristian and Ganesh, Vijay and Pawlowski, Peter M. and Dill, David L. and Engler, Dawson R.},
  title      = {EXE: Automatically Generating Inputs of Death},
  year       = {2008},
  issue_date = {December 2008},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {12},
  number     = {2},
  issn       = {1094-9224},
  url        = {https://doi.org/10.1145/1455518.1455522},
  doi        = {10.1145/1455518.1455522},
  abstract   = {This article presents EXE, an effective bug-finding tool that automatically generates inputs that crash real code. Instead of running code on manually or randomly constructed input, EXE runs it on symbolic input initially allowed to be anything. As checked code runs, EXE tracks the constraints on each symbolic (i.e., input-derived) memory location. If a statement uses a symbolic value, EXE does not run it, but instead adds it as an input-constraint; all other statements run as usual. If code conditionally checks a symbolic expression, EXE forks execution, constraining the expression to be true on the true branch and false on the other. Because EXE reasons about all possible values on a path, it has much more power than a traditional runtime tool: (1) it can force execution down any feasible program path and (2) at dangerous operations (e.g., a pointer dereference), it detects if the current path constraints allow any value that causes a bug. When a path terminates or hits a bug, EXE automatically generates a test case by solving the current path constraints to find concrete values using its own co-designed constraint solver, STP. Because EXE’s constraints have no approximations, feeding this concrete input to an uninstrumented version of the checked code will cause it to follow the same path and hit the same bug (assuming deterministic code).EXE works well on real code, finding bugs along with inputs that trigger them in: the BSD and Linux packet filter implementations, the dhcpd DHCP server, the pcre regular expression library, and three Linux file systems.},
  journal    = {ACM Trans. Inf. Syst. Secur.},
  month      = {12},
  articleno  = {10},
  numpages   = {38},
  keywords   = {test case generation, constraint solving, symbolic execution, attack generation, dynamic analysis, bug finding}
}

@inproceedings{RWset,
  author    = {Boonstoppel, Peter and Cadar, Cristian and Engler, Dawson},
  title     = {RWset: Attacking Path Explosion in Constraint-Based Test Generation},
  year      = {2008},
  isbn      = {3540787992},
  publisher = {Springer-Verlag},
  address   = {Berlin, Heidelberg},
  abstract  = {Recent work has used variations of symbolic execution to automatically generate high-coverage test inputs [3, 4, 7, 8, 14]. Such tools have demonstrated their ability to find very subtle errors. However, one challenge they all face is how to effectively handle the exponential number of paths in checked code. This paper presents a new technique for reducing the number of traversed code paths by discarding those that must have side-effects identical to some previously explored path. Our results on a mix of open source applications and device drivers show that this (sound) optimization reduces the numbers of paths traversed by several orders of magnitude, often achieving program coverage far out of reach for a standard constraint-based execution system.},
  booktitle = {Proceedings of the Theory and Practice of Software, 14th International Conference on Tools and Algorithms for the Construction and Analysis of Systems},
  pages     = {351–366},
  numpages  = {16},
  location  = {Budapest, Hungary},
  series    = {TACAS'08/ETAPS'08}
}

@inproceedings{CREST,
  author    = {Burnim, Jacob and Sen, Koushik},
  booktitle = {2008 23rd IEEE/ACM International Conference on Automated Software Engineering},
  title     = {Heuristics for Scalable Dynamic Test Generation},
  year      = {2008},
  volume    = {},
  number    = {},
  pages     = {443-446},
  doi       = {10.1109/ASE.2008.69}
}

@inproceedings{BuildItBreakItFixIt,
  author    = {Ruef, Andrew and Hicks, Michael and Parker, James and Levin, Dave and Mazurek, Michelle L. and Mardziel, Piotr},
  title     = {Build It, Break It, Fix It: Contesting Secure Development},
  year      = {2016},
  isbn      = {9781450341394},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/2976749.2978382},
  doi       = {10.1145/2976749.2978382},
  abstract  = {Typical security contests focus on breaking or mitigating the impact of buggy systems. We present the Build-it, Break-it, Fix-it (BIBIFI) contest, which aims to assess the ability to securely build software, not just break it. In BIBIFI, teams build specified software with the goal of maximizing correctness, performance, and security. The latter is tested when teams attempt to break other teams' submissions. Winners are chosen from among the best builders and the best breakers. BIBIFI was designed to be open-ended-teams can use any language, tool, process, etc. that they like. As such, contest outcomes shed light on factors that correlate with successfully building secure software and breaking insecure software. During 2015, we ran three contests involving a total of 116 teams and two different programming problems. Quantitative analysis from these contests found that the most efficient build-it submissions used C/C++, but submissions coded in other statically-typed languages were less likely to have a security flaw; build-it teams with diverse programming-language knowledge also produced more secure code. Shorter programs correlated with better scores. Break-it teams that were also successful build-it teams were significantly better at finding security bugs.},
  booktitle = {Proceedings of the 2016 ACM SIGSAC Conference on Computer and Communications Security},
  pages     = {690–703},
  numpages  = {14},
  keywords  = {software engineering, security},
  location  = {Vienna, Austria},
  series    = {CCS '16}
}

@inproceedings{FIXREVERTER,
  author    = {Zenong Zhang and Zach Patterson and Michael Hicks and Shiyi Wei},
  title     = {{FIXREVERTER}: A Realistic Bug Injection Methodology for Benchmarking Fuzz Testing},
  booktitle = {31st USENIX Security Symposium (USENIX Security 22)},
  year      = {2022},
  isbn      = {978-1-939133-31-1},
  address   = {Boston, MA},
  pages     = {3699--3715},
  url       = {https://www.usenix.org/conference/usenixsecurity22/presentation/zhang-zenong},
  publisher = {USENIX Association},
  month     = {08}
}

@inproceedings{UnTracer,
  author    = {Nagy, Stefan and Hicks, Matthew},
  booktitle = {2019 IEEE Symposium on Security and Privacy (SP)},
  title     = {Full-Speed Fuzzing: Reducing Fuzzing Overhead through Coverage-Guided Tracing},
  year      = {2019},
  volume    = {},
  number    = {},
  pages     = {787-802},
  doi       = {10.1109/SP.2019.00069}
}

@inproceedings{ZAFL,
  author    = {Stefan Nagy and Anh Nguyen-Tuong and Jason D. Hiser and Jack W. Davidson and Matthew Hicks},
  title     = {Breaking Through Binaries: Compiler-quality Instrumentation for Better Binary-only Fuzzing},
  booktitle = {30th USENIX Security Symposium (USENIX Security 21)},
  year      = {2021},
  isbn      = {978-1-939133-24-3},
  pages     = {1683--1700},
  url       = {https://www.usenix.org/conference/usenixsecurity21/presentation/nagy},
  publisher = {USENIX Association},
  month     = {08}
}

@inproceedings{HardwareFuzzingPipeline,
  author    = {Timothy Trippel and Kang G. Shin and Alex Chernyakhovsky and Garret Kelly and Dominic Rizzo and Matthew Hicks},
  title     = {Fuzzing Hardware Like Software},
  booktitle = {31st USENIX Security Symposium (USENIX Security 22)},
  year      = {2022},
  isbn      = {978-1-939133-31-1},
  address   = {Boston, MA},
  pages     = {3237--3254},
  url       = {https://www.usenix.org/conference/usenixsecurity22/presentation/trippel},
  publisher = {USENIX Association},
  month     = {08}
}

@article{CGPT,
  author     = {Lampropoulos, Leonidas and Hicks, Michael and Pierce, Benjamin C.},
  title      = {Coverage Guided, Property Based Testing},
  year       = {2019},
  issue_date = {October 2019},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {3},
  number     = {OOPSLA},
  url        = {https://doi.org/10.1145/3360607},
  doi        = {10.1145/3360607},
  abstract   = {Property-based random testing, exemplified by frameworks such as Haskell's QuickCheck, works by testing an executable predicate (a property) on a stream of randomly generated inputs. Property testing works very well in many cases, but not always. Some properties are conditioned on the input satisfying demanding semantic invariants that are not consequences of its syntactic structure---e.g., that an input list must be sorted or have no duplicates. Most randomly generated inputs fail to satisfy properties with such sparse preconditions, and so are simply discarded. As a result, much of the target system may go untested. We address this issue with a novel technique called coverage guided, property based testing (CGPT). Our approach is inspired by the related area of coverage guided fuzzing, exemplified by tools like AFL. Rather than just generating a fresh random input at each iteration, CGPT can also produce new inputs by mutating previous ones using type-aware, generic mutator operators. The target program is instrumented to track which control flow branches are executed during a run and inputs whose runs expand control-flow coverage are retained for future mutations. This means that, when sparse conditions in the target are satisfied and new coverage is observed, the input that triggered them will be retained and used as a springboard to go further. We have implemented CGPT as an extension to the QuickChick property testing tool for Coq programs; we call our implementation FuzzChick. We evaluate FuzzChick on two Coq developments for abstract machines that aim to enforce flavors of noninterference, which has a (very) sparse precondition. We systematically inject bugs in the machines' checking rules and use FuzzChick to look for counterexamples to the claim that they satisfy a standard noninterference property. We find that vanilla QuickChick almost always fails to find any bugs after a long period of time, as does an earlier proposal for combining property testing and fuzzing. In contrast, FuzzChick often finds them within seconds to minutes. Moreover, FuzzChick is almost fully automatic; although highly tuned, hand-written generators can find the bugs faster, they require substantial amounts of insight and manual effort.},
  journal    = {Proc. ACM Program. Lang.},
  month      = {10},
  articleno  = {181},
  numpages   = {29},
  keywords   = {coverage, fuzz testing, FuzzChick, random testing, QuickChick, property-based testing, AFL}
}

@inproceedings{KATCH,
  author    = {Marinescu, Paul Dan and Cadar, Cristian},
  title     = {KATCH: High-Coverage Testing of Software Patches},
  year      = {2013},
  isbn      = {9781450322379},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/2491411.2491438},
  doi       = {10.1145/2491411.2491438},
  abstract  = {One of the distinguishing characteristics of software systems is that they evolve: new patches are committed to software repositories and new versions are released to users on a continuous basis. Unfortunately, many of these changes bring unexpected bugs that break the stability of the system or affect its security. In this paper, we address this problem using a technique for automatically testing code patches. Our technique combines symbolic execution with several novel heuristics based on static and dynamic program analysis which allow it to quickly reach the code of the patch. We have implemented our approach in a tool called KATCH, which we have applied to all the patches written in a combined period of approximately six years for nineteen mature programs from the popular GNU diffutils, GNU binutils and GNU findutils utility suites, which are shipped with virtually all UNIX-based distributions. Our results show that KATCH can automatically synthesise inputs that significantly increase the patch coverage achieved by the existing manual test suites, and find bugs at the moment they are introduced.},
  booktitle = {Proceedings of the 2013 9th Joint Meeting on Foundations of Software Engineering},
  pages     = {235–245},
  numpages  = {11},
  keywords  = {Patch Testing, Symbolic Execution},
  location  = {Saint Petersburg, Russia},
  series    = {ESEC/FSE 2013}
}

@inproceedings{KLEEFP,
  author    = {Collingbourne, Peter and Cadar, Cristian and Kelly, Paul H.J.},
  title     = {Symbolic Crosschecking of Floating-Point and SIMD Code},
  year      = {2011},
  isbn      = {9781450306348},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/1966445.1966475},
  doi       = {10.1145/1966445.1966475},
  abstract  = {We present an effective technique for crosschecking an IEEE 754 floating-point program and its SIMD-vectorized version, implemented in KLEE-FP, an extension to the KLEE symbolic execution tool that supports symbolic reasoning on the equivalence between floating-point values.The key insight behind our approach is that floatingpoint values are only reliably equal if they are essentially built by the same operations. As a result, our technique works by lowering the Intel Streaming SIMD Extension (SSE) instruction set to primitive integer and floating-point operations, and then using an algorithm based on symbolic expression matching augmented with canonicalization rules.Under symbolic execution, we have to verify equivalence along every feasible control-flow path. We reduce the branching factor of this process by aggressively merging conditionals, if-converting branches into select operations via an aggressive phi-node folding transformation.We applied KLEE-FP to OpenCV, a popular open source computer vision library. KLEE-FP was able to successfully crosscheck 51 SIMD/SSE implementations against their corresponding scalar versions, proving the bounded equivalence of 41 of them (i.e., on images up to a certain size), and finding inconsistencies in the other 10.},
  booktitle = {Proceedings of the Sixth Conference on Computer Systems},
  pages     = {315–328},
  numpages  = {14},
  keywords  = {sse, bounded verification, simd, klee-fp, symbolic crosschecking},
  location  = {Salzburg, Austria},
  series    = {EuroSys '11}
}

@inproceedings{Covrig,
  author    = {Marinescu, Paul and Hosek, Petr and Cadar, Cristian},
  title     = {Covrig: A Framework for the Analysis of Code, Test, and Coverage Evolution in Real Software},
  year      = {2014},
  isbn      = {9781450326452},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/2610384.2610419},
  doi       = {10.1145/2610384.2610419},
  abstract  = {Software repositories provide rich information about the construction and evolution of software systems. While static data that can be mined directly from version control systems has been extensively studied, dynamic metrics concerning the execution of the software have received much less attention, due to the inherent difficulty of running and monitoring a large number of software versions. In this paper, we present Covrig, a flexible infrastructure that can be used to run each version of a system in isolation and collect static and dynamic software metrics, using a lightweight virtual machine environment that can be deployed on a cluster of local or cloud machines. We use Covrig to conduct an empirical study examining how code and tests co-evolve in six popular open-source systems. We report the main characteristics of software patches, analyse the evolution of program and patch coverage, assess the impact of nondeterminism on the execution of test suites, and investigate whether the coverage of code containing bugs and bug fixes is higher than average.},
  booktitle = {Proceedings of the 2014 International Symposium on Software Testing and Analysis},
  pages     = {93–104},
  numpages  = {12},
  keywords  = {bugs and fixes, coverage evolution, latent patch cover- age, nondeterministic coverage, Patch characteristics},
  location  = {San Jose, CA, USA},
  series    = {ISSTA 2014}
}

@inproceedings{AutomaticTestingSymbex,
  author    = {Kapus, Timotej and Cadar, Cristian},
  booktitle = {2017 32nd IEEE/ACM International Conference on Automated Software Engineering (ASE)},
  title     = {Automatic testing of symbolic execution engines via program generation and differential testing},
  year      = {2017},
  volume    = {},
  number    = {},
  pages     = {590-600},
  doi       = {10.1109/ASE.2017.8115669}
}

@inproceedings{JFS,
  author    = {Liew, Daniel and Cadar, Cristian and Donaldson, Alastair F. and Stinnett, J. Ryan},
  title     = {Just Fuzz It: Solving Floating-Point Constraints Using Coverage-Guided Fuzzing},
  year      = {2019},
  isbn      = {9781450355728},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/3338906.3338921},
  doi       = {10.1145/3338906.3338921},
  abstract  = {We investigate the use of coverage-guided fuzzing as a means of proving satisfiability of SMT formulas over finite variable domains, with specific application to floating-point constraints. We show how an SMT formula can be encoded as a program containing a location that is reachable if and only if the program’s input corresponds to a satisfying assignment to the formula. A coverage-guided fuzzer can then be used to search for an input that reaches the location, yielding a satisfying assignment. We have implemented this idea in a tool, Just Fuzz-it Solver (JFS), and we present a large experimental evaluation showing that JFS is both competitive with and complementary to state-of-the-art SMT solvers with respect to solving floating-point constraints, and that the coverage-guided approach of JFS provides significant benefit over naive fuzzing in the floating-point domain. Applied in a portfolio manner, the JFS approach thus has the potential to complement traditional SMT solvers for program analysis tasks that involve reasoning about floating-point constraints.},
  booktitle = {Proceedings of the 2019 27th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering},
  pages     = {521–532},
  numpages  = {12},
  keywords  = {feedback-directed fuzzing, Constraint solving},
  location  = {Tallinn, Estonia},
  series    = {ESEC/FSE 2019}
}

@inproceedings{ZESTI,
  author    = {Dan Marinescu, Paul and Cadar, Cristian},
  booktitle = {2012 34th International Conference on Software Engineering (ICSE)},
  title     = {make test-zesti: A symbolic execution solution for improving regression testing},
  year      = {2012},
  volume    = {},
  number    = {},
  pages     = {716-726},
  doi       = {10.1109/ICSE.2012.6227146}
}

@inproceedings{ZEST,
  author    = {Padhye, Rohan and Lemieux, Caroline and Sen, Koushik and Papadakis, Mike and Le Traon, Yves},
  title     = {Semantic Fuzzing with Zest},
  year      = {2019},
  isbn      = {9781450362245},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/3293882.3330576},
  doi       = {10.1145/3293882.3330576},
  abstract  = {Programs expecting structured inputs often consist of both a syntactic analysis stage, which parses raw input, and a semantic analysis stage, which conducts checks on the parsed input and executes the core logic of the program. Generator-based testing tools in the lineage of QuickCheck are a promising way to generate random syntactically valid test inputs for these programs. We present Zest, a technique which automatically guides QuickCheck-like random input generators to better explore the semantic analysis stage of test programs. Zest converts random-input generators into deterministic parametric input generators. We present the key insight that mutations in the untyped parameter domain map to structural mutations in the input domain. Zest leverages program feedback in the form of code coverage and input validity to perform feedback-directed parameter search. We evaluate Zest against AFL and QuickCheck on five Java programs: Maven, Ant, BCEL, Closure, and Rhino. Zest covers 1.03x-2.81x as many branches within the benchmarks' semantic analysis stages as baseline techniques. Further, we find 10 new bugs in the semantic analysis stages of these benchmarks. Zest is the most effective technique in finding these bugs reliably and quickly, requiring at most 10 minutes on average to find each bug.},
  booktitle = {Proceedings of the 28th ACM SIGSOFT International Symposium on Software Testing and Analysis},
  pages     = {329–340},
  numpages  = {12},
  keywords  = {property-based testing, Structure-aware fuzzing, random testing},
  location  = {Beijing, China},
  series    = {ISSTA 2019}
}
@article{FuzzFactory,
  author     = {Padhye, Rohan and Lemieux, Caroline and Sen, Koushik and Simon, Laurent and Vijayakumar, Hayawardh},
  title      = {FuzzFactory: Domain-Specific Fuzzing with Waypoints},
  year       = {2019},
  issue_date = {October 2019},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {3},
  number     = {OOPSLA},
  url        = {https://doi.org/10.1145/3360600},
  doi        = {10.1145/3360600},
  abstract   = {Coverage-guided fuzz testing has gained prominence as a highly effective method of finding security vulnerabilities such as buffer overflows in programs that parse binary data. Recently, researchers have introduced various specializations to the coverage-guided fuzzing algorithm for different domain-specific testing goals, such as finding performance bottlenecks, generating valid inputs, handling magic-byte comparisons, etc. Each such solution can require non-trivial implementation effort and produces a distinct variant of a fuzzing tool. We observe that many of these domain-specific solutions follow a common solution pattern. In this paper, we present FuzzFactory, a framework for developing domain-specific fuzzing applications without requiring changes to mutation and search heuristics. FuzzFactory allows users to specify the collection of dynamic domain-specific feedback during test execution, as well as how such feedback should be aggregated. FuzzFactory uses this information to selectively save intermediate inputs, called waypoints, to augment coverage-guided fuzzing. Such waypoints always make progress towards domain-specific multi-dimensional objectives. We instantiate six domain-specific fuzzing applications using FuzzFactory: three re-implementations of prior work and three novel solutions, and evaluate their effectiveness on benchmarks from Google's fuzzer test suite. We also show how multiple domains can be composed to perform better than the sum of their parts. For example, we combine domain-specific feedback about strict equality comparisons and dynamic memory allocations, to enable the automatic generation of LZ4 bombs and PNG bombs.},
  journal    = {Proc. ACM Program. Lang.},
  month      = {10},
  articleno  = {174},
  numpages   = {29},
  keywords   = {waypoints, fuzz testing, frameworks, domain-specific fuzzing}
}

@inproceedings{FairFuzz,
  author    = {Lemieux, Caroline and Sen, Koushik},
  title     = {FairFuzz: A Targeted Mutation Strategy for Increasing Greybox Fuzz Testing Coverage},
  year      = {2018},
  isbn      = {9781450359375},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/3238147.3238176},
  doi       = {10.1145/3238147.3238176},
  abstract  = {In recent years, fuzz testing has proven itself to be one of the most effective techniques for finding correctness bugs and security vulnerabilities in practice. One particular fuzz testing tool, American Fuzzy Lop (AFL), has become popular thanks to its ease-of-use and bug-finding power. However, AFL remains limited in the bugs it can find since it simply does not cover large regions of code. If it does not cover parts of the code, it will not find bugs there. We propose a two-pronged approach to increase the coverage achieved by AFL. First, the approach automatically identifies branches exercised by few AFL-produced inputs (rare branches), which often guard code that is empirically hard to cover by naively mutating inputs. The second part of the approach is a novel mutation mask creation algorithm, which allows mutations to be biased towards producing inputs hitting a given rare branch. This mask is dynamically computed during fuzz testing and can be adapted to other testing targets. We implement this approach on top of AFL in a tool named FairFuzz. We conduct evaluation on real-world programs against state-of-the-art versions of AFL. We find that on these programs FairFuzz achieves high branch coverage at a faster rate that state-of-the-art versions of AFL. In addition, on programs with nested conditional structure, it achieves sustained increases in branch coverage after 24 hours (average 10.6\% increase). In qualitative analysis, we find that FairFuzz has an increased capacity to automatically discover keywords.},
  booktitle = {Proceedings of the 33rd ACM/IEEE International Conference on Automated Software Engineering},
  pages     = {475–485},
  numpages  = {11},
  keywords  = {coverage-guided greybox fuzzing, fuzz testing, rare branches},
  location  = {Montpellier, France},
  series    = {ASE '18}
}

@inproceedings{JQF,
  author    = {Padhye, Rohan and Lemieux, Caroline and Sen, Koushik},
  title     = {JQF: Coverage-Guided Property-Based Testing in Java},
  year      = {2019},
  isbn      = {9781450362245},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/3293882.3339002},
  doi       = {10.1145/3293882.3339002},
  abstract  = {We present JQF, a platform for performing coverage-guided fuzz testing in Java. JQF is designed both for practitioners, who wish to find bugs in Java programs, as well as for researchers, who wish to implement new fuzzing algorithms. Practitioners write QuickCheck-style test methods that take inputs as formal parameters. JQF instruments the test program's bytecode and continuously executes tests using inputs that are generated in a coverage-guided fuzzing loop. JQF's input-generation mechanism is extensible. Researchers can implement custom fuzzing algorithms by extending JQF's Guidance interface. A Guidance instance responds to code coverage events generated during the execution of a test case, such as function calls and conditional jumps, and provides the next input. We describe several guidances that currently ship with JQF, such as: semantic fuzzing with Zest, binary fuzzing with AFL, and complexity fuzzing with PerfFuzz. JQF is a mature tool that is open-source and publicly available. At the time of writing, JQF has been successful in discovering 42 previously unknown bugs in widely used open-source software such as OpenJDK, Apache Commons, and the Google Closure Compiler.},
  booktitle = {Proceedings of the 28th ACM SIGSOFT International Symposium on Software Testing and Analysis},
  pages     = {398–401},
  numpages  = {4},
  keywords  = {property-based testing, QuickCheck, Coverage-guided fuzzing},
  location  = {Beijing, China},
  series    = {ISSTA 2019}
}

@inproceedings{PerfFuzz,
  author    = {Lemieux, Caroline and Padhye, Rohan and Sen, Koushik and Song, Dawn},
  title     = {PerfFuzz: Automatically Generating Pathological Inputs},
  year      = {2018},
  isbn      = {9781450356992},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/3213846.3213874},
  doi       = {10.1145/3213846.3213874},
  abstract  = {Performance problems in software can arise unexpectedly when programs are provided with inputs that exhibit worst-case behavior. A large body of work has focused on diagnosing such problems via statistical profiling techniques. But how does one find these inputs in the first place? We present PerfFuzz, a method to automatically generate inputs that exercise pathological behavior across program locations, without any domain knowledge. PerfFuzz generates inputs via feedback-directed mutational fuzzing. Unlike previous approaches that attempt to maximize only a scalar characteristic such as the total execution path length, PerfFuzz uses multi-dimensional feedback and independently maximizes execution counts for all program locations. This enables PerfFuzz to (1) find a variety of inputs that exercise distinct hot spots in a program and (2) generate inputs with higher total execution path length than previous approaches by escaping local maxima. PerfFuzz is also effective at generating inputs that demonstrate algorithmic complexity vulnerabilities. We implement PerfFuzz on top of AFL, a popular coverage-guided fuzzing tool, and evaluate PerfFuzz on four real-world C programs typically used in the fuzzing literature. We find that PerfFuzz outperforms prior work by generating inputs that exercise the most-hit program branch 5x to 69x times more, and result in 1.9x to 24.7x longer total execution paths.},
  booktitle = {Proceedings of the 27th ACM SIGSOFT International Symposium on Software Testing and Analysis},
  pages     = {254–265},
  numpages  = {12},
  keywords  = {fuzz testing, algorithmic complexity, worst-case, performance},
  location  = {Amsterdam, Netherlands},
  series    = {ISSTA 2018}
}

@inproceedings{RFUZZ,
  author    = {Laeufer, Kevin and Koenig, Jack and Kim, Donggyu and Bachrach, Jonathan and Sen, Koushik},
  booktitle = {2018 IEEE/ACM International Conference on Computer-Aided Design (ICCAD)},
  title     = {RFUZZ: Coverage-Directed Fuzz Testing of RTL on FPGAs},
  year      = {2018},
  volume    = {},
  number    = {},
  pages     = {1-8},
  doi       = {10.1145/3240765.3240842}
}

@inproceedings{RLCheck,
  author    = {Reddy, Sameer and Lemieux, Caroline and Padhye, Rohan and Sen, Koushik},
  title     = {Quickly Generating Diverse Valid Test Inputs with Reinforcement Learning},
  year      = {2020},
  isbn      = {9781450371216},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/3377811.3380399},
  doi       = {10.1145/3377811.3380399},
  abstract  = {Property-based testing is a popular approach for validating the logic of a program. An effective property-based test quickly generates many diverse valid test inputs and runs them through a parameterized test driver. However, when the test driver requires strict validity constraints on the inputs, completely random input generation fails to generate enough valid inputs. Existing approaches to solving this problem rely on whitebox or greybox information collected by instrumenting the input generator and/or test driver. However, collecting such information reduces the speed at which tests can be executed. In this paper, we propose and study a black-box approach for generating valid test inputs. We first formalize the problem of guiding random input generators towards producing a diverse set of valid inputs. This formalization highlights the role of a guide which governs the space of choices within a random input generator. We then propose a solution based on reinforcement learning (RL), using a tabular, on-policy RL approach to guide the generator. We evaluate this approach, RLCheck, against pure random input generation as well as a state-of-the-art greybox evolutionary algorithm, on four real-world benchmarks. We find that in the same time budget, RLCheck generates an order of magnitude more diverse valid inputs than the baselines.},
  booktitle = {Proceedings of the ACM/IEEE 42nd International Conference on Software Engineering},
  pages     = {1410–1421},
  numpages  = {12},
  location  = {Seoul, South Korea},
  series    = {ICSE '20}
}

@inproceedings{QuickSampler,
  author    = {Dutra, Rafael and Laeufer, Kevin and Bachrach, Jonathan and Sen, Koushik},
  title     = {Efficient Sampling of SAT Solutions for Testing},
  year      = {2018},
  isbn      = {9781450356381},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/3180155.3180248},
  doi       = {10.1145/3180155.3180248},
  abstract  = {In software and hardware testing, generating multiple inputs which satisfy a given set of constraints is an important problem with applications in fuzz testing and stimulus generation. However, it is a challenge to perform the sampling efficiently, while generating a diverse set of inputs which satisfy the constraints. We developed a new algorithm QuickSampler which requires a small number of solver calls to produce millions of samples which satisfy the constraints with high probability. We evaluate QuickSampler on large real-world benchmarks and show that it can produce unique valid solutions orders of magnitude faster than other state-of-the-art sampling tools, with a distribution which is reasonably close to uniform in practice.},
  booktitle = {Proceedings of the 40th International Conference on Software Engineering},
  pages     = {549–559},
  numpages  = {11},
  keywords  = {sampling, constraint-based testing, stimulus generation, constrained-random verification},
  location  = {Gothenburg, Sweden},
  series    = {ICSE '18}
}

@inproceedings{PARTEMU,
  author    = {Lee Harrison and Hayawardh Vijayakumar and Rohan Padhye and Koushik Sen and Michael Grace},
  title     = {{PARTEMU}: Enabling Dynamic Analysis of {Real-World} {TrustZone} Software Using Emulation},
  booktitle = {29th USENIX Security Symposium (USENIX Security 20)},
  year      = {2020},
  isbn      = {978-1-939133-17-5},
  pages     = {789--806},
  url       = {https://www.usenix.org/conference/usenixsecurity20/presentation/harrison},
  publisher = {USENIX Association},
  month     = {08}
}

@article{JavaScript2,
  author     = {Andreasen, Esben and Gong, Liang and M\o{}ller, Anders and Pradel, Michael and Selakovic, Marija and Sen, Koushik and Staicu, Cristian-Alexandru},
  title      = {A Survey of Dynamic Analysis and Test Generation for JavaScript},
  year       = {2017},
  issue_date = {September 2018},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {50},
  number     = {5},
  issn       = {0360-0300},
  url        = {https://doi.org/10.1145/3106739},
  doi        = {10.1145/3106739},
  abstract   = {JavaScript has become one of the most prevalent programming languages. Unfortunately, some of the unique properties that contribute to this popularity also make JavaScript programs prone to errors and difficult for program analyses to reason about. These properties include the highly dynamic nature of the language, a set of unusual language features, a lack of encapsulation mechanisms, and the “no crash” philosophy. This article surveys dynamic program analysis and test generation techniques for JavaScript targeted at improving the correctness, reliability, performance, security, and privacy of JavaScript-based software.},
  journal    = {ACM Comput. Surv.},
  month      = {09},
  articleno  = {66},
  numpages   = {36},
  keywords   = {test generation, dynamic languages, Program analysis}
}

@article{Ethereum,
  author  = {Kushwaha, Satpal Singh and Joshi, Sandeep and Singh, Dilbag and Kaur, Manjit and Lee, Heung-No},
  journal = {IEEE Access},
  title   = {Ethereum Smart Contract Analysis Tools: A Systematic Review},
  year    = {2022},
  volume  = {10},
  number  = {},
  pages   = {57037-57062},
  doi     = {10.1109/ACCESS.2022.3169902}
}

@article{Embedded2,
  author   = {Eisele, Max
              and Maugeri, Marcello
              and Shriwas, Rachna
              and Huth, Christopher
              and Bella, Giampaolo},
  title    = {Embedded fuzzing: a review of challenges, tools, and solutions},
  journal  = {Cybersecurity},
  year     = {2022},
  month    = {09},
  day      = {02},
  volume   = {5},
  number   = {1},
  pages    = {18},
  abstract = {Fuzzing has become one of the best-established methods to uncover software bugs. Meanwhile, the market of embedded systems, which binds the software execution tightly to the very hardware architecture, has grown at a steady pace, and that pace is anticipated to become yet more sustained in the near future. Embedded systems also benefit from fuzzing, but the innumerable existing architectures and hardware peripherals complicate the development of general and usable approaches, hence a plethora of tools have recently appeared. Here comes a stringent need for a systematic review in the area of fuzzing approaches for embedded systems, which we term ``embedded fuzzing'' for brevity. The inclusion criteria chosen in this article are semi-objective in their coverage of the most relevant publication venues as well as of our personal judgement. The review rests on a formal definition we develop to represent the realm of embedded fuzzing. It continues by discussing the approaches that satisfy the inclusion criteria, then defines the relevant elements of comparison and groups the approaches according to how the execution environment is served to the system under test. The resulting review produces a table with 42 entries, which in turn supports discussion suggesting vast room for future research due to the limitations noted.},
  issn     = {2523-3246},
  doi      = {10.1186/s42400-022-00123-y},
  url      = {https://doi.org/10.1186/s42400-022-00123-y}
}

@article{Network2023,
  author         = {Zhang, Zhaowei and Zhang, Hongzheng and Zhao, Jinjing and Yin, Yanfei},
  title          = {A Survey on the Development of Network Protocol Fuzzing Techniques},
  journal        = {Electronics},
  volume         = {12},
  year           = {2023},
  number         = {13},
  article-number = {2904},
  url            = {https://www.mdpi.com/2079-9292/12/13/2904},
  issn           = {2079-9292},
  abstract       = {Network protocols, as the communication rules among computer network devices, are the foundation for the normal operation of networks. However, security issues arising from design flaws and implementation vulnerabilities in network protocols pose significant risks to network operations and security. Network protocol fuzzing is an effective technique for discovering and mitigating security flaws in network protocols. It offers unparalleled advantages compared to other security analysis techniques thanks to the minimal requirement for prior knowledge of the target and low deployment complexity. Nevertheless, the randomness in test case generation, uncontrollable test coverage, and unstable testing efficiency introduce challenges in ensuring the controllability of the testing process and results. In order to comprehensively survey the development of network protocol fuzzing techniques and analyze their advantages and existing issues, in this paper, we categorized and summarized the protocol fuzzing and its related techniques based on the generation methods of test cases and testing conditions. Specifically, we overviewed the development trajectory and patterns of these techniques over the past two decades according to chronological order. Based on this analysis, we further predict the future directions of fuzzing techniques.},
  doi            = {10.3390/electronics12132904}
}

@article{Hybrid,
  author  = {Rustamov, Fayozbek and Kim, Juhwan and Yu, Jihyeon and Yun, Joobeom},
  journal = {IEEE Access},
  title   = {Exploratory Review of Hybrid Fuzzing for Automated Vulnerability Detection},
  year    = {2021},
  volume  = {9},
  number  = {},
  pages   = {131166-131190},
  doi     = {10.1109/ACCESS.2021.3114202}
}

@inproceedings{Skyfire,
  author    = {Wang, Junjie and Chen, Bihuan and Wei, Lei and Liu, Yang},
  booktitle = {2017 IEEE Symposium on Security and Privacy (SP)},
  title     = {Skyfire: Data-Driven Seed Generation for Fuzzing},
  year      = {2017},
  volume    = {},
  number    = {},
  pages     = {579-594},
  doi       = {10.1109/SP.2017.23}
}

@inproceedings{Orthrus,
  author    = {Shastry, Bhargava
               and Leutner, Markus
               and Fiebig, Tobias
               and Thimmaraju, Kashyap
               and Yamaguchi, Fabian
               and Rieck, Konrad
               and Schmid, Stefan
               and Seifert, Jean-Pierre
               and Feldmann, Anja},
  editor    = {Dacier, Marc
               and Bailey, Michael
               and Polychronakis, Michalis
               and Antonakakis, Manos},
  title     = {Static Program Analysis as a Fuzzing Aid},
  booktitle = {Research in Attacks, Intrusions, and Defenses},
  year      = {2017},
  publisher = {Springer International Publishing},
  address   = {Cham},
  pages     = {26--47},
  abstract  = {Fuzz testing is an effective and scalable technique to perform software security assessments. Yet, contemporary fuzzers fall short of thoroughly testing applications with a high degree of control-flow diversity, such as firewalls and network packet analyzers. In this paper, we demonstrate how static program analysis can guide fuzzing by augmenting existing program models maintained by the fuzzer. Based on the insight that code patterns reflect the data format of inputs processed by a program, we automatically construct an input dictionary by statically analyzing program control and data flow. Our analysis is performed before fuzzing commences, and the input dictionary is supplied to an off-the-shelf fuzzer to influence input generation. Evaluations show that our technique not only increases test coverage by 10--15{\%} over baseline fuzzers such as afl but also reduces the time required to expose vulnerabilities by up to an order of magnitude. As a case study, we have evaluated our approach on two classes of network applications: nDPI, a deep packet inspection library, and tcpdump, a network packet analyzer. Using our approach, we have uncovered 15 zero-day vulnerabilities in the evaluated software that were not found by stand-alone fuzzers. Our work not only provides a practical method to conduct security evaluations more effectively but also demonstrates that the synergy between program analysis and testing can be exploited for a better outcome.},
  isbn      = {978-3-319-66332-6}
}

@article{QuickFuzz,
  author     = {Grieco, Gustavo and Ceresa, Mart\'{\i}n and Buiras, Pablo},
  title      = {QuickFuzz: An Automatic Random Fuzzer for Common File Formats},
  year       = {2016},
  issue_date = {December 2016},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {51},
  number     = {12},
  issn       = {0362-1340},
  url        = {https://doi.org/10.1145/3241625.2976017},
  doi        = {10.1145/3241625.2976017},
  abstract   = {Fuzzing is a technique that involves testing programs using invalid or erroneous inputs. Most fuzzers require a set of valid inputs as a starting point, in which mutations are then introduced. QuickFuzz is a fuzzer that leverages QuickCheck-style random test-case generationto automatically test programs that manipulate common file formats by fuzzing. We rely on existing Haskell implementations of file-format-handling libraries found on Hackage, the community-driven Haskell code repository. We have tried QuickFuzz in the wild and found that the approach is effective in discovering vulnerabilities in real-world implementations of browsers, image processing utilities and file compressors among others. In addition, we introduce a mechanism to automatically derive random generators for the types representing these formats. QuickFuzz handles most well-known image and media formats, and can be used to test programs and libraries written in any language.},
  journal    = {SIGPLAN Not.},
  month      = {09},
  pages      = {13–20},
  numpages   = {8},
  keywords   = {QuickCheck, Haskell, Hackage, Fuzzing}
}

@article{QuickFuzz2,
  title    = {QuickFuzz testing for fun and profit},
  journal  = {Journal of Systems and Software},
  volume   = {134},
  pages    = {340-354},
  year     = {2017},
  issn     = {0164-1212},
  doi      = {https://doi.org/10.1016/j.jss.2017.09.018},
  url      = {https://www.sciencedirect.com/science/article/pii/S0164121217302066},
  author   = {Gustavo Grieco and Martín Ceresa and Agustín Mista and Pablo Buiras},
  keywords = {Testing, Fuzzing, Haskell, QuickCheck},
  abstract = {Fuzzing is a popular technique to find flaws in programs using invalid or erroneous inputs but not without its drawbacks. At one hand, mutational fuzzers require a set of valid inputs as a starting point, in which modifications are then introduced. On the other hand, generational fuzzing allows to synthesize somehow valid inputs according to a specification. Unfortunately, this requires to have a deep knowledge of the file formats under test to write specifications of them to guide the test case generation process. In this paper we introduce an extended and improved version of QuickFuzz, a tool written in Haskell designed for testing unexpected inputs of common file formats on third-party software, taking advantage of off-the-self well known fuzzers. Unlike other generational fuzzers, QuickFuzz does not require to write specifications for the file formats in question since it relies on existing file-format-handling libraries available on the Haskell code repository. It supports almost 40 different complex file-types including images, documents, source code and digital certificates. In particular, we found QuickFuzz useful enough to discover many previously unknown vulnerabilities on real-world implementations of web browsers and image processing libraries among others.}
}

@inproceedings{DIFUZE,
  author    = {Corina, Jake and Machiry, Aravind and Salls, Christopher and Shoshitaishvili, Yan and Hao, Shuang and Kruegel, Christopher and Vigna, Giovanni},
  title     = {DIFUZE: Interface Aware Fuzzing for Kernel Drivers},
  year      = {2017},
  isbn      = {9781450349468},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/3133956.3134069},
  doi       = {10.1145/3133956.3134069},
  abstract  = {Device drivers are an essential part in modern Unix-like systems to handle operations on physical devices, from hard disks and printers to digital cameras and Bluetooth speakers. The surge of new hardware, particularly on mobile devices, introduces an explosive growth of device drivers in system kernels. Many such drivers are provided by third-party developers, which are susceptible to security vulnerabilities and lack proper vetting. Unfortunately, the complex input data structures for device drivers render traditional analysis tools, such as fuzz testing, less effective, and so far, research on kernel driver security is comparatively sparse. In this paper, we present DIFUZE, an interface-aware fuzzing tool to automatically generate valid inputs and trigger the execution of the kernel drivers. We leverage static analysis to compose correctly-structured input in the userspace to explore kernel drivers. DIFUZE is fully automatic, ranging from identifying driver handlers, to mapping to device file names, to constructing complex argument instances. We evaluate our approach on seven modern Android smartphones. The results show that DIFUZE can effectively identify kernel driver bugs, and reports 32 previously unknown vulnerabilities, including flaws that lead to arbitrary code execution.},
  booktitle = {Proceedings of the 2017 ACM SIGSAC Conference on Computer and Communications Security},
  pages     = {2123–2138},
  numpages  = {16},
  keywords  = {kernel drivers, fuzzing, interface aware},
  location  = {Dallas, Texas, USA},
  series    = {CCS '17}
}

@inproceedings{Angora,
  author    = {Chen, Peng and Chen, Hao},
  booktitle = {2018 IEEE Symposium on Security and Privacy (SP)},
  title     = {Angora: Efficient Fuzzing by Principled Search},
  year      = {2018},
  volume    = {},
  number    = {},
  pages     = {711-725},
  doi       = {10.1109/SP.2018.00046}
}

@inproceedings{Steelix,
  author    = {Li, Yuekang and Chen, Bihuan and Chandramohan, Mahinthan and Lin, Shang-Wei and Liu, Yang and Tiu, Alwen},
  title     = {Steelix: Program-State Based Binary Fuzzing},
  year      = {2017},
  isbn      = {9781450351058},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/3106237.3106295},
  doi       = {10.1145/3106237.3106295},
  abstract  = {Coverage-based fuzzing is one of the most effective techniques to find vulnerabilities, bugs or crashes. However, existing techniques suffer from the difficulty in exercising the paths that are protected by magic bytes comparisons (e.g., string equality comparisons). Several approaches have been proposed to use heavy-weight program analysis to break through magic bytes comparisons, and hence are less scalable. In this paper, we propose a program-state based binary fuzzing approach, named Steelix, which improves the penetration power of a fuzzer at the cost of an acceptable slow down of the execution speed. In particular, we use light-weight static analysis and binary instrumentation to provide not only coverage information but also comparison progress information to a fuzzer. Such program state information informs a fuzzer about where the magic bytes are located in the test input and how to perform mutations to match the magic bytes efficiently. We have implemented Steelix and evaluated it on three datasets: LAVA-M dataset, DARPA CGC sample binaries and five real-life programs. The results show that Steelix has better code coverage and bug detection capability than the state-of-the-art fuzzers. Moreover, we found one CVE and nine new bugs.},
  booktitle = {Proceedings of the 2017 11th Joint Meeting on Foundations of Software Engineering},
  pages     = {627–637},
  numpages  = {11},
  keywords  = {binary instrumentation, binary fuzzing, coverage-based fuzzing},
  location  = {Paderborn, Germany},
  series    = {ESEC/FSE 2017}
}

@inproceedings{MutaGen,
  author    = {Karg\'{e}n, Ulf and Shahmehri, Nahid},
  title     = {Turning Programs against Each Other: High Coverage Fuzz-Testing Using Binary-Code Mutation and Dynamic Slicing},
  year      = {2015},
  isbn      = {9781450336758},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/2786805.2786844},
  doi       = {10.1145/2786805.2786844},
  abstract  = {Mutation-based fuzzing is a popular and widely employed black-box testing technique for finding security and robustness bugs in software. It owes much of its success to its simplicity; a well-formed seed input is mutated, e.g. through random bit-flipping, to produce test inputs. While reducing the need for human effort, and enabling security testing even of closed-source programs with undocumented input formats, the simplicity of mutation-based fuzzing comes at the cost of poor code coverage. Often millions of iterations are needed, and the results are highly dependent on configuration parameters and the choice of seed inputs. In this paper we propose a novel method for automated generation of high-coverage test cases for robustness testing. Our method is based on the observation that, even for closed-source programs with proprietary input formats, an implementation that can generate well-formed inputs to the program is typically available. By systematically mutating the program code of such generating programs, we leverage information about the input format encoded in the generating program to produce high-coverage test inputs, capable of reaching deep states in the program under test. Our method works entirely at the machine-code level, enabling use-cases similar to traditional black-box fuzzing. We have implemented the method in our tool MutaGen, and evaluated it on 7 popular Linux programs. We found that, for most programs, our method improves code coverage by one order of magnitude or more, compared to two well-known mutation-based fuzzers. We also found a total of 8 unique bugs.},
  booktitle = {Proceedings of the 2015 10th Joint Meeting on Foundations of Software Engineering},
  pages     = {782–792},
  numpages  = {11},
  keywords  = {program mutation, black-box, dynamic slicing, fuzzing, Fuzz testing},
  location  = {Bergamo, Italy},
  series    = {ESEC/FSE 2015}
}
@inproceedings{SDF,
  author    = {Lin, Ying-Dar and Liao, Feng-Ze and Huang, Shih-Kun and Lai, Yuan-Cheng},
  booktitle = {2015 International Carnahan Conference on Security Technology (ICCST)},
  title     = {Browser fuzzing by scheduled mutation and generation of document object models},
  year      = {2015},
  volume    = {},
  number    = {},
  pages     = {1-6},
  doi       = {10.1109/CCST.2015.7389677}
}

@inproceedings{SCADA,
  author    = {Hyunguk Yoo and Taeshik Shon},
  booktitle = {2016 IEEE International Conference on Smart Grid Communications (SmartGridComm)},
  title     = {Grammar-based adaptive fuzzing: Evaluation on SCADA modbus protocol},
  year      = {2016},
  volume    = {},
  number    = {},
  pages     = {557-563},
  doi       = {10.1109/SmartGridComm.2016.7778820}
}

@inproceedings{IMF,
  author    = {Han, HyungSeok and Cha, Sang Kil},
  title     = {IMF: Inferred Model-Based Fuzzer},
  year      = {2017},
  isbn      = {9781450349468},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/3133956.3134103},
  doi       = {10.1145/3133956.3134103},
  abstract  = {Kernel vulnerabilities are critical in security because they naturally allow attackers to gain unprivileged root access. Although there has been much research on finding kernel vulnerabilities from source code, there are relatively few research on kernel fuzzing, which is a practical bug finding technique that does not require any source code. Existing kernel fuzzing techniques involve feeding in random input values to kernel API functions. However, such a simple approach does not reveal latent bugs deep in the kernel code, because many API functions are dependent on each other, and they can quickly reject arbitrary parameter values based on their calling context. In this paper, we propose a novel fuzzing technique for commodity OS kernels that leverages inferred dependence model between API function calls to discover deep kernel bugs. We implement our technique on a fuzzing system, called IMF. IMF has already found 32 previously unknown kernel vulnerabilities on the latest macOS version 10.12.3 (16D32) at the time of this writing.},
  booktitle = {Proceedings of the 2017 ACM SIGSAC Conference on Computer and Communications Security},
  pages     = {2345–2358},
  numpages  = {14},
  keywords  = {api fuzzing, kernel vulnerabilities, fuzzing, model-based fuzzing},
  location  = {Dallas, Texas, USA},
  series    = {CCS '17}
}

@inproceedings{Chizpurfle,
  author    = {Iannillo, Antonio Ken and Natella, Roberto and Cotroneo, Domenico and Nita-Rotaru, Cristina},
  booktitle = {2017 IEEE 28th International Symposium on Software Reliability Engineering (ISSRE)},
  title     = {Chizpurfle: A Gray-Box Android Fuzzer for Vendor Service Customizations},
  year      = {2017},
  volume    = {},
  number    = {},
  pages     = {1-11},
  doi       = {10.1109/ISSRE.2017.16}
}

@inproceedings{S2F,
  author    = {Zhang, Bin and Ye, Jiaxi and Feng, Chao and Tang, Chaojing},
  booktitle = {2017 13th International Conference on Computational Intelligence and Security (CIS)},
  title     = {S2F: Discover Hard-to-Reach Vulnerabilities by Semi-Symbolic Fuzz Testing},
  year      = {2017},
  volume    = {},
  number    = {},
  pages     = {548-552},
  doi       = {10.1109/CIS.2017.00127}
}

@inproceedings{OS,
  author    = {Xu, Wen and Kashyap, Sanidhya and Min, Changwoo and Kim, Taesoo},
  title     = {Designing New Operating Primitives to Improve Fuzzing Performance},
  year      = {2017},
  isbn      = {9781450349468},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/3133956.3134046},
  doi       = {10.1145/3133956.3134046},
  abstract  = {Fuzzing is a software testing technique that finds bugs by repeatedly injecting mutated inputs to a target program. Known to be a highly practical approach, fuzzing is gaining more popularity than ever before. Current research on fuzzing has focused on producing an input that is more likely to trigger a vulnerability.In this paper, we tackle another way to improve the performance of fuzzing, which is to shorten the execution time of each iteration. We observe that AFL, a state-of-the-art fuzzer, slows down by 24x because of file system contention and the scalability of fork() system call when it runs on 120 cores in parallel. Other fuzzers are expected to suffer from the same scalability bottlenecks in that they follow a similar design pattern. To improve the fuzzing performance, we design and implement three new operating primitives specialized for fuzzing that solve these performance bottlenecks and achieve scalable performance on multi-core machines. Our experiment shows that the proposed primitives speed up AFL and LibFuzzer by 6.1 to 28.9x and 1.1 to 735.7x, respectively, on the overall number of executions per second when targeting Google's fuzzer test suite with 120 cores. In addition, the primitives improve AFL's throughput up to 7.7x with 30 cores, which is a more common setting in data centers. Our fuzzer-agnostic primitives can be easily applied to any fuzzer with fundamental performance improvement and directly benefit large-scale fuzzing and cloud-based fuzzing services.},
  booktitle = {Proceedings of the 2017 ACM SIGSAC Conference on Computer and Communications Security},
  pages     = {2313–2328},
  numpages  = {16},
  keywords  = {scalability, operating system, fuzzing},
  location  = {Dallas, Texas, USA},
  series    = {CCS '17}
}
@inproceedings{VDF,
  author    = {Henderson, Andrew
               and Yin, Heng
               and Jin, Guang
               and Han, Hao
               and Deng, Hongmei},
  editor    = {Dacier, Marc
               and Bailey, Michael
               and Polychronakis, Michalis
               and Antonakakis, Manos},
  title     = {VDF: Targeted Evolutionary Fuzz Testing of Virtual Devices},
  booktitle = {Research in Attacks, Intrusions, and Defenses},
  year      = {2017},
  publisher = {Springer International Publishing},
  address   = {Cham},
  pages     = {3--25},
  abstract  = {As cloud computing becomes more and more prevalent, there is increased interest in mitigating attacks that target hypervisors from within the virtualized guest environments that they host. We present VDF, a targeted evolutionary fuzzing framework for discovering bugs within the software-based virtual devices implemented as part of a hypervisor. To achieve this, VDF selectively instruments the code of a given virtual device, and performs record and replay of memory-mapped I/O (MMIO) activity specific to the virtual device. We evaluate VDF by performing cloud-based parallel fuzz testing of eighteen virtual devices implemented within the QEMU hypervisor, executing over two billion test cases and revealing over one thousand unique crashes or hangs in one third of the tested devices. Our custom test case minimization algorithm further reduces the erroneous test cases into only 18.57{\%} of the original sizes on average.},
  isbn      = {978-3-319-66332-6}
}

@inproceedings{kAFL,
  author    = {Sergej Schumilo and Cornelius Aschermann and Robert Gawlik and Sebastian Schinzel and Thorsten Holz},
  title     = {{kAFL}: {Hardware-Assisted} Feedback Fuzzing for {OS} Kernels},
  booktitle = {26th USENIX Security Symposium (USENIX Security 17)},
  year      = {2017},
  isbn      = {978-1-931971-40-9},
  address   = {Vancouver, BC},
  pages     = {167--182},
  url       = {https://www.usenix.org/conference/usenixsecurity17/technical-sessions/presentation/schumilo},
  publisher = {USENIX Association},
  month     = {08}
}

@inproceedings{MEDS,
  title     = {Enhancing Memory Error Detection for Large-Scale Applications and Fuzz Testing},
  author    = {Wookhyun Han and Byunggill Joe and Byoungyoung Lee and Chengyu Song and Insik Shin},
  booktitle = {Network and Distributed System Security Symposium},
  year      = {2018},
  url       = {https://api.semanticscholar.org/CorpusID:3837287}
}

@inproceedings{SlowFuzz,
  author    = {Petsios, Theofilos and Zhao, Jason and Keromytis, Angelos D. and Jana, Suman},
  title     = {SlowFuzz: Automated Domain-Independent Detection of Algorithmic Complexity Vulnerabilities},
  year      = {2017},
  isbn      = {9781450349468},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/3133956.3134073},
  doi       = {10.1145/3133956.3134073},
  abstract  = {Algorithmic complexity vulnerabilities occur when the worst-case time/space complexity of an application is significantly higher than the respective average case for particular user-controlled inputs. When such conditions are met, an attacker can launch Denial-of-Service attacks against a vulnerable application by providing inputs that trigger the worst-case behavior. Such attacks have been known to have serious effects on production systems, take down entire websites, or lead to bypasses of Web Application Firewalls.Unfortunately, existing detection mechanisms for algorithmic complexity vulnerabilities are domain-specific and often require significant manual effort. In this paper, we design, implement, and evaluate SlowFuzz, a domain-independent framework for automatically finding algorithmic complexity vulnerabilities. SlowFuzz automatically finds inputs that trigger worst-case algorithmic behavior in the tested binary. SlowFuzz uses resource-usage-guided evolutionary search techniques to automatically find inputs that maximize computational resource utilization for a given application.We demonstrate that SlowFuzz successfully generates inputs that match the theoretical worst-case performance for several well-known algorithms. SlowFuzz was also able to generate a large number of inputs that trigger different algorithmic complexity vulnerabilities in real-world applications, including various zip parsers used in antivirus software, regular expression libraries used in Web Application Firewalls, as well as hash table implementations used in Web applications. In particular, SlowFuzz generated inputs that achieve 300-times slowdown in the decompression routine of the bzip utility, discovered regular expressions that exhibit matching times exponential in the input size, and also managed to automatically produce inputs that trigger a high number of collisions in PHP's default hashtable implementation.},
  booktitle = {Proceedings of the 2017 ACM SIGSAC Conference on Computer and Communications Security},
  pages     = {2155–2168},
  numpages  = {14},
  keywords  = {algorithmic complexity attacks, dos attacks, fuzzing, resource exhaustion attacks},
  location  = {Dallas, Texas, USA},
  series    = {CCS '17}
}

@inproceedings{NEZHA,
  author    = {Petsios, Theofilos and Tang, Adrian and Stolfo, Salvatore and Keromytis, Angelos D. and Jana, Suman},
  booktitle = {2017 IEEE Symposium on Security and Privacy (SP)},
  title     = {NEZHA: Efficient Domain-Independent Differential Testing},
  year      = {2017},
  volume    = {},
  number    = {},
  pages     = {615-632},
  doi       = {10.1109/SP.2017.27}
}

@inproceedings{CGF,
  author    = {B\"{o}hme, Marcel and Pham, Van-Thuan and Roychoudhury, Abhik},
  title     = {Coverage-Based Greybox Fuzzing as Markov Chain},
  year      = {2016},
  isbn      = {9781450341394},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/2976749.2978428},
  doi       = {10.1145/2976749.2978428},
  abstract  = {Coverage-based Greybox Fuzzing (CGF) is a random testing approach that requires no program analysis. A new test is generated by slightly mutating a seed input. If the test exercises a new and interesting path, it is added to the set of seeds; otherwise, it is discarded. We observe that most tests exercise the same few "high-frequency" paths and develop strategies to explore significantly more paths with the same number of tests by gravitating towards low-frequency paths. We explain the challenges and opportunities of CGF using a Markov chain model which specifies the probability that fuzzing the seed that exercises path i generates an input that exercises path j. Each state (i.e., seed) has an energy that specifies the number of inputs to be generated from that seed. We show that CGF is considerably more efficient if energy is inversely proportional to the density of the stationary distribution and increases monotonically every time that seed is chosen. Energy is controlled with a power schedule.We implemented the exponential schedule by extending AFL. In 24 hours, AFLFAST exposes 3 previously unreported CVEs that are not exposed by AFL and exposes 6 previously unreported CVEs 7x faster than AFL. AFLFAST produces at least an order of magnitude more unique crashes than AFL.},
  booktitle = {Proceedings of the 2016 ACM SIGSAC Conference on Computer and Communications Security},
  pages     = {1032–1043},
  numpages  = {12},
  keywords  = {software security, testing efficiency, vulnerability detection, foundations, fuzzing},
  location  = {Vienna, Austria},
  series    = {CCS '16}
}

@inproceedings{SeedSelection,
  author    = {Rebert, Alexandre and Cha, Sang Kil and Avgerinos, Thanassis and Foote, Jonathan and Warren, David and Grieco, Gustavo and Brumley, David},
  title     = {Optimizing Seed Selection for Fuzzing},
  year      = {2014},
  isbn      = {9781931971157},
  publisher = {USENIX Association},
  address   = {USA},
  abstract  = {Randomly mutating well-formed program inputs or simply fuzzing, is a highly effective and widely used strategy to find bugs in software. Other than showing fuzzers find bugs, there has been little systematic effort in understanding the science of how to fuzz properly. In this paper, we focus on how to mathematically formulate and reason about one critical aspect in fuzzing: how best to pick seed files to maximize the total number of bugs found during a fuzz campaign. We design and evaluate six different algorithms using over 650 CPU days on Amazon Elastic Compute Cloud (EC2) to provide ground truth data. Overall, we find 240 bugs in 8 applications and show that the choice of algorithm can greatly increase the number of bugs found. We also show that current seed selection strategies as found in Peach may fare no better than picking seeds at random. We make our data set and code publicly available.},
  booktitle = {Proceedings of the 23rd USENIX Conference on Security Symposium},
  pages     = {861–875},
  numpages  = {15},
  location  = {San Diego, CA},
  series    = {SEC'14}
}

@inproceedings{Scheduling,
  author    = {Woo, Maverick and Cha, Sang Kil and Gottlieb, Samantha and Brumley, David},
  title     = {Scheduling Black-Box Mutational Fuzzing},
  year      = {2013},
  isbn      = {9781450324779},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/2508859.2516736},
  doi       = {10.1145/2508859.2516736},
  abstract  = {Black-box mutational fuzzing is a simple yet effective technique to find bugs in software. Given a set of program-seed pairs, we ask how to schedule the fuzzings of these pairs in order to maximize the number of unique bugs found at any point in time. We develop an analytic framework using a mathematical model of black-box mutational fuzzing and use it to evaluate 26 existing and new randomized online scheduling algorithms. Our experiments show that one of our new scheduling algorithms outperforms the multi-armed bandit algorithm in the current version of the CERT Basic Fuzzing Framework (BFF) by finding 1.5x more unique bugs in the same amount of time.},
  booktitle = {Proceedings of the 2013 ACM SIGSAC Conference on Computer \& Communications Security},
  pages     = {511–522},
  numpages  = {12},
  keywords  = {fuzz configuration scheduling, software security},
  location  = {Berlin, Germany},
  series    = {CCS '13}
}

@inproceedings{SMART,
  author    = {Godefroid, Patrice},
  title     = {Compositional Dynamic Test Generation},
  year      = {2007},
  isbn      = {1595935754},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/1190216.1190226},
  doi       = {10.1145/1190216.1190226},
  abstract  = {Dynamic test generation is a form of dynamic program analysis that attempts to compute test inputs to drive a program along a specific program path. Directed Automated Random Testing, or DART for short, blends dynamic test generation with model checking techniques with the goal of systematically executing all feasible program paths of a program while detecting various types of errors using run-time checking tools (like Purify, for instance). Unfortunately, systematically executing all feasible program paths does not scale to large, realistic programs.This paper addresses this major limitation and proposes to perform dynamic test generation compositionally, by adapting known techniques for interprocedural static analysis. Specifically, we introduce a new algorithm, dubbed SMART for Systematic Modular Automated Random Testing, that extends DART by testing functions in isolation, encoding test results as function summaries expressed using input preconditions and output postconditions, and then re-using those summaries when testing higher-level functions. We show that, for a fixed reasoning capability, our compositional approach to dynamic test generation (SMART) is both sound and complete compared to monolithic dynamic test generation (DART). In other words, SMART can perform dynamic test generation compositionally without any reduction in program path coverage. We also show that, given a bound on the maximum number of feasible paths in individual program functions, the number of program executions explored by SMART is linear in that bound, while the number of program executions explored by DART can be exponential in that bound. We present examples of C programs and preliminary experimental results that illustrate and validate empirically these properties.},
  booktitle = {Proceedings of the 34th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
  pages     = {47–54},
  numpages  = {8},
  keywords  = {program verification, scalability, automatic test generation, software testing, compositional program analysis},
  location  = {Nice, France},
  series    = {POPL '07}
}

@inproceedings{AllYouEverWanted,
  author    = {Schwartz, Edward J. and Avgerinos, Thanassis and Brumley, David},
  booktitle = {2010 IEEE Symposium on Security and Privacy},
  title     = {All You Ever Wanted to Know about Dynamic Taint Analysis and Forward Symbolic Execution (but Might Have Been Afraid to Ask)},
  year      = {2010},
  volume    = {},
  number    = {},
  pages     = {317-331},
  doi       = {10.1109/SP.2010.26}
}

@inproceedings{GSE,
  author    = {Khurshid, Sarfraz
               and P{\u{A}}s{\u{A}}reanu, Corina S.
               and Visser, Willem},
  editor    = {Garavel, Hubert
               and Hatcliff, John},
  title     = {Generalized Symbolic Execution for Model Checking and Testing},
  booktitle = {Tools and Algorithms for the Construction and Analysis of Systems},
  year      = {2003},
  publisher = {Springer Berlin Heidelberg},
  address   = {Berlin, Heidelberg},
  pages     = {553--568},
  abstract  = {Modern software systems, which often are concurrent and manipulate complex data structures must be extremely reliable. We present a novel framework based on symbolic execution, for automated checking of such systems. We provide a two-fold generalization of traditional symbolic execution based approaches. First, we define a source to source translation to instrument a program, which enables standard model checkers to perform symbolic execution of the program. Second, we give a novel symbolic execution algorithm that handles dynamically allocated structures (e.g., lists and trees), method preconditions (e.g., acyclicity), data (e.g., integers and strings) and concurrency. The program instrumentation enables a model checker to automatically explore different program heap configurations and manipulate logical formulae on program data (using a decision procedure). We illustrate two applications of our framework: checking correctness of multi-threaded programs that take inputs from unbounded domains with complex structure and generation of non-isomorphic test inputs that satisfy a testing criterion. Our implementation for Java uses the Java PathFinder model checker.},
  isbn      = {978-3-540-36577-8}
}


@inproceedings{EGT,
  author    = {Cadar, Cristian
               and Engler, Dawson},
  editor    = {Godefroid, Patrice},
  title     = {Execution Generated Test Cases: How to Make Systems Code Crash Itself},
  booktitle = {Model Checking Software},
  year      = {2005},
  publisher = {Springer Berlin Heidelberg},
  address   = {Berlin, Heidelberg},
  pages     = {2--23},
  abstract  = {This paper presents a technique that uses code to automatically generate its own test cases at run time by using a combination of symbolic and concrete (i.e regular) execution The input values to a program (or software component) provide the standard interface of any testing framework with the program it is testing and generating input values that will explore all the ``interesting'' behavior in the tested program remains an important open problem in software testing research. Our approach works by turning the problem on its head: we lazily generate from within the program itself the input values to the program (and values derived from input values) as needed. We applied the technique to real code and found numerous corner case errors ranging from simple memory overflows and infinite loops to subtle issues in the interpretation of language standards.},
  isbn      = {978-3-540-31899-6}
}

@inproceedings{HCT,
  author    = {Majumdar, Rupak and Sen, Koushik},
  booktitle = {29th International Conference on Software Engineering (ICSE'07)},
  title     = {Hybrid Concolic Testing},
  year      = {2007},
  volume    = {},
  number    = {},
  pages     = {416-426},
  doi       = {10.1109/ICSE.2007.41}
}

@article{DiSE,
  author     = {Yang, Guowei and Person, Suzette and Rungta, Neha and Khurshid, Sarfraz},
  title      = {Directed Incremental Symbolic Execution},
  year       = {2014},
  issue_date = {September 2014},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {24},
  number     = {1},
  issn       = {1049-331X},
  url        = {https://doi.org/10.1145/2629536},
  doi        = {10.1145/2629536},
  abstract   = {The last few years have seen a resurgence of interest in the use of symbolic execution—a program analysis technique developed more than three decades ago to analyze program execution paths. Scaling symbolic execution to real systems remains challenging despite recent algorithmic and technological advances. An effective approach to address scalability is to reduce the scope of the analysis. For example, in regression analysis, differences between two related program versions are used to guide the analysis. While such an approach is intuitive, finding efficient and precise ways to identify program differences, and characterize their impact on how the program executes has proved challenging in practice.In this article, we present Directed Incremental Symbolic Execution (DiSE), a novel technique for detecting and characterizing the impact of program changes to scale symbolic execution. The novelty of DiSE is to combine the efficiencies of static analysis techniques to compute program difference information with the precision of symbolic execution to explore program execution paths and generate path conditions affected by the differences. DiSE complements other reduction and bounding techniques for improving symbolic execution. Furthermore, DiSE does not require analysis results to be carried forward as the software evolves—only the source code for two related program versions is required. An experimental evaluation using our implementation of DiSE illustrates its effectiveness at detecting and characterizing the effects of program changes.},
  journal    = {ACM Trans. Softw. Eng. Methodol.},
  month      = {10},
  articleno  = {3},
  numpages   = {42},
  keywords   = {symbolic execution, software evolution, Program differencing}
}

@inproceedings{FloPSy,
  author    = {Lakhotia, Kiran
               and Tillmann, Nikolai
               and Harman, Mark
               and de Halleux, Jonathan},
  editor    = {Petrenko, Alexandre
               and Sim{\~a}o, Adenilso
               and Maldonado, Jos{\'e} Carlos},
  title     = {FloPSy - Search-Based Floating Point Constraint Solving for Symbolic Execution},
  booktitle = {Testing Software and Systems},
  year      = {2010},
  publisher = {Springer Berlin Heidelberg},
  address   = {Berlin, Heidelberg},
  pages     = {142--157},
  abstract  = {Recently there has been an upsurge of interest in both, Search--Based Software Testing (SBST), and Dynamic Symbolic Execution (DSE). Each of these two approaches has complementary strengths and weaknesses, making it a natural choice to explore the degree to which the strengths of one can be exploited to offset the weakness of the other. This paper introduces an augmented version of DSE that uses a SBST--based approach to handling floating point computations, which are known to be problematic for vanilla DSE. The approach has been implemented as a plug in for the Microsoft Pex DSE testing tool. The paper presents results from both, standard evaluation benchmarks, and two open source programs.},
  isbn      = {978-3-642-16573-3}
}

@inproceedings{CORAL,
  author    = {Souza, Matheus
               and Borges, Mateus
               and d'Amorim, Marcelo
               and P{\u{a}}s{\u{a}}reanu, Corina S.},
  editor    = {Bobaru, Mihaela
               and Havelund, Klaus
               and Holzmann, Gerard J.
               and Joshi, Rajeev},
  title     = {CORAL: Solving Complex Constraints for Symbolic PathFinder},
  booktitle = {NASA Formal Methods},
  year      = {2011},
  publisher = {Springer Berlin Heidelberg},
  address   = {Berlin, Heidelberg},
  pages     = {359--374},
  abstract  = {Symbolic execution is a powerful automated technique for generating test cases. Its goal is to achieve high coverage of software. One major obstacle in adopting the technique in practice is its inability to handle complex mathematical constraints. To address the problem, we have integrated CORAL's heuristic solvers into NASA Ames' Symbolic PathFinder symbolic execution tool. CORAL's solvers have been designed to deal with mathematical constraints and their heuristics have been improved based on examples from the aerospace domain. This integration significantly broadens the application of Symbolic PathFinder at NASA and in industry.},
  isbn      = {978-3-642-20398-5}
}

@article{DynamicPartialOrderReduction,
  author     = {Flanagan, Cormac and Godefroid, Patrice},
  title      = {Dynamic Partial-Order Reduction for Model Checking Software},
  year       = {2005},
  issue_date = {January 2005},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {40},
  number     = {1},
  issn       = {0362-1340},
  url        = {https://doi.org/10.1145/1047659.1040315},
  doi        = {10.1145/1047659.1040315},
  abstract   = {We present a new approach to partial-order reduction for model checking software. This approach is based on initially exploring an arbitrary interleaving of the various concurrent processes/threads, and dynamically tracking interactions between these to identify backtracking points where alternative paths in the state space need to be explored. We present examples of multi-threaded programs where our new dynamic partial-order reduction technique significantly reduces the search space, even though traditional partial-order algorithms are helpless.},
  journal    = {SIGPLAN Not.},
  month      = {jan},
  pages      = {110–121},
  numpages   = {12},
  keywords   = {partial-order reduction, software model checking}
}


@techreport{LATEST,
  author      = {Majumdar, Rupak and Sen, Koushik},
  title       = {LATEST: Lazy Dynamic Test Input Generation},
  institution = {EECS Department, University of California, Berkeley},
  year        = {2007},
  month       = {03},
  url         = {http://www2.eecs.berkeley.edu/Pubs/TechRpts/2007/EECS-2007-36.html},
  number      = {UCB/EECS-2007-36},
  abstract    = {  We present lazy expansion, a new algorithm for scalable test
                 input generation using directed concolic execution.  Lazy expansion
                 is an instantiation of the counterexample-guided refinement paradigm
                 from static software verification in the context of testing.  Our
                 algorithm works in two phases.  It first explores, using concolic
                 execution, an abstraction of the function under test by replacing
                 each called function with an unconstrained input.  Second, for each
                 (possibly spurious) trace generated by this abstraction, it attempts
                 to expand the trace to a concretely realizable execution by
                 recursively expanding the called functions and finding concrete
                 executions in the called functions that can be stitched together
                 with the original trace to form a complete program execution.  Thus,
                 it reduces the burden of symbolic reasoning about interprocedural
                 paths to reasoning about intraprocedural paths (in the exploration
                 phase), together with a localized and constrained search through
                 functions (in the concretization phase).
                 
                 Lazy expansion is particularly effective in testing functions that
                 make more-or-less independent calls to lower level library functions
                 (that have already been unit tested), by only exploring relevant
                 paths in the function under test.  We have implemented our algorithm
                 on top of the CUTE concolic execution tool for C and applied it to
                 testing parser code in small compilers.  In preliminary experiments,
                 our tool, called LATEST, outperformed CUTE by an order of
                 magnitude in terms of the time taken to generate inputs, and in
                 contrast to CUTE, produced many syntactically valid input strings
                 which exercised interesting paths through the compiler (rather than
                 only the parser error handling code).}
}

@article{SPIN,
  author     = {Siegel, Stephen F. and Mironova, Anastasia and Avrunin, George S. and Clarke, Lori A.},
  title      = {Combining Symbolic Execution with Model Checking to Verify Parallel Numerical Programs},
  year       = {2008},
  issue_date = {April 2008},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {17},
  number     = {2},
  issn       = {1049-331X},
  url        = {https://doi.org/10.1145/1348250.1348256},
  doi        = {10.1145/1348250.1348256},
  abstract   = {We present a method to verify the correctness of parallel programs that perform complex numerical computations, including computations involving floating-point arithmetic. This method requires that a sequential version of the program be provided, to serve as the specification for the parallel one. The key idea is to use model checking, together with symbolic execution, to establish the equivalence of the two programs. In this approach the path condition from symbolic execution of the sequential program is used to constrain the search through the parallel program. To handle floating-point operations, three different types of equivalence are supported. Several examples are presented, demonstrating the approach and actual errors that were found. Limitations and directions for future research are also described.},
  journal    = {ACM Trans. Softw. Eng. Methodol.},
  month      = {05},
  articleno  = {10},
  numpages   = {34},
  keywords   = {Finite-state verification, symbolic execution, high performance computing, parallel programming, floating-point, concurrency, numerical program, model checking, Spin, Message Passing Interface, MPI}
}

@inproceedings{DTSA,
  author    = {Xu, Zhihong and Kim, Yunho and Kim, Moonzoo and Rothermel, Gregg and Cohen, Myra B.},
  title     = {Directed Test Suite Augmentation: Techniques and Tradeoffs},
  year      = {2010},
  isbn      = {9781605587912},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/1882291.1882330},
  doi       = {10.1145/1882291.1882330},
  abstract  = {Test suite augmentation techniques are used in regression testing to identify code elements affected by changes and to generate test cases to cover those elements. Our preliminary work suggests that several factors influence the cost and effectiveness of test suite augmentation techniques. These include the order in which affected elements are considered while generating test cases, the manner in which existing regression test cases and newly generated test cases are used, and the algorithm used to generate test cases. In this work, we present the results of an empirical study examining these factors, considering two test case generation algorithms (concolic and genetic). The results of our experiment show that the primary factor affecting augmentation is the test case generation algorithm utilized; this affects both cost and effectiveness. The manner in which existing and newly generated test cases are utilized also has a substantial effect on efficiency but a lesser effect on effectiveness. The order in which affected elements are considered turns out to have relatively few effects when using concolic test case generation, but more substantial effects when using genetic test case generation.},
  booktitle = {Proceedings of the Eighteenth ACM SIGSOFT International Symposium on Foundations of Software Engineering},
  pages     = {257–266},
  numpages  = {10},
  keywords  = {concolic testing, test suite augmentation, empirical studies, genetic algorithms, regression testing},
  location  = {Santa Fe, New Mexico, USA},
  series    = {FSE '10}
}

@inproceedings{Z3,
  author    = {de Moura, Leonardo
               and Bj{\o}rner, Nikolaj},
  editor    = {Ramakrishnan, C. R.
               and Rehof, Jakob},
  title     = {Z3: An Efficient SMT Solver},
  booktitle = {Tools and Algorithms for the Construction and Analysis of Systems},
  year      = {2008},
  publisher = {Springer Berlin Heidelberg},
  address   = {Berlin, Heidelberg},
  pages     = {337--340},
  abstract  = {Satisfiability Modulo Theories (SMT) problem is a decision problem for logical first order formulas with respect to combinations of background theories such as: arithmetic, bit-vectors, arrays, and uninterpreted functions. Z3 is a new and efficient SMT Solver freely available from Microsoft Research. It is used in various software verification and analysis applications.},
  isbn      = {978-3-540-78800-3}
}

@inproceedings{STP,
  author    = {Ganesh, Vijay
               and Dill, David L.},
  editor    = {Damm, Werner
               and Hermanns, Holger},
  title     = {A Decision Procedure for Bit-Vectors and Arrays},
  booktitle = {Computer Aided Verification},
  year      = {2007},
  publisher = {Springer Berlin Heidelberg},
  address   = {Berlin, Heidelberg},
  pages     = {519--531},
  abstract  = {STP is a decision procedure for the satisfiability of quantifier-free formulas in the theory of bit-vectors and arrays that has been optimized for large problems encountered in software analysis applications. The basic architecture of the procedure consists of word-level pre-processing algorithms followed by translation to SAT. The primary bottlenecks in software verification and bug finding applications are large arrays and linear bit-vector arithmetic. New algorithms based on the abstraction-refinement paradigm are presented for reasoning about large arrays. A solver for bit-vector linear arithmetic is presented that eliminates variables and parts of variables to enable other transformations, and reduce the size of the problem that is eventually received by the SAT solver.},
  isbn      = {978-3-540-73368-3}
}


@phdthesis{ScalableAutomatedMethods,
  author    = {Sen, Koushik},
  advisor   = {Agha, Gul},
  title     = {Scalable Automated Methods for Dynamic Program Analysis},
  year      = {2006},
  isbn      = {9780542990465},
  publisher = {University of Illinois at Urbana-Champaign},
  address   = {USA},
  abstract  = {Testing using manually generated test cases is the primary technique used in industry to improve reliability of software---in fact, such  ad hoc  testing accounts for over half of the typical cost of software development. We propose new methods for systematically and automatically testing sequential and concurrent programs. The methods are based on three new techniques:  concolic testing, race-detection and flipping,  and  predictive monitoring . Concolic testing combines concrete and symbolic testing to avoid redundant test cases as well as false warnings. Concolic testing can catch generic errors such as assertion violations, uncaught exceptions, and segmentation faults. Large real-world programs are almost always concurrent. Because of the inherent non-determinism of such programs, testing is notoriously hard. We extend concolic testing with a method called  race-detection and flipping , which provides ways of reducing, often exponentially, the exploration space for concolic testing. This combined method provides the first technique to effectively test concurrent programs with complex data inputs. Concolic testing may also be combined with formal specifications by using  runtime monitors . Runtime monitors are small software units which are synthesized automatically from the formal specification for the software and weaved into the code to dynamically check if the specification is violated. For multi-threaded concurrent programs, we developed a novel technique which allows efficient  predictive monitoring  to enable the detection of a violation by observing some related, but possibly bug free execution of a concurrent program. Predictive monitoring dramatically improves the efficiency of testing. Based on the above methods we have developed tools for testing both C and Java programs. We have used the tools to find bugs in several real-world software systems including SGLIB, a popular C data structure library used in a commercial tool, implementations of the Needham-Schroeder protocol and the TMN protocol, the scheduler of Honeywell's DEOS real-time operating system, and the Sum Microsystems' JDK 1.4 collection framework.},
  note      = {AAI3242987}
}

@inproceedings{OpenDistributedPrograms,
  author    = {Sen, Koushik
               and Agha, Gul},
  editor    = {Baresi, Luciano
               and Heckel, Reiko},
  title     = {Automated Systematic Testing of Open Distributed Programs},
  booktitle = {Fundamental Approaches to Software Engineering},
  year      = {2006},
  publisher = {Springer Berlin Heidelberg},
  address   = {Berlin, Heidelberg},
  pages     = {339--356},
  abstract  = {We present an algorithm for automatic testing of distributed programs, such as Unix processes with inter-process communication, Web services, etc. Specifically, we assume that a program consists of a number of asynchronously executing concurrent processes or actors which may take data inputs and communicate using asynchronous messages. Because of the large numbers of possible data inputs as well as the asynchrony in the execution and communication, distributed programs exhibit very large numbers of potential behaviors. Our goal is two fold: to execute all reachable statements of a program, and to detect deadlock states. Specifically, our algorithm uses simultaneous concrete and symbolic execution, or concolic execution, to explore all distinct behaviors that may result from a program's execution given different data inputs and schedules. The key idea is as follows. We use the symbolic execution to generate data inputs that may lead to alternate behaviors. At the same time, we use the concrete execution to determine, at runtime, the partial order of events in the program's execution. This enables us to improve the efficiency of our algorithm by avoiding many tests which would result in equivalent behaviors. We describe our experience with a prototype tool that we have developed as a part of our Java program testing tool jCUTE.},
  isbn      = {978-3-540-33094-3}
}

@inproceedings{ExplicitPathModelChecking,
  author    = {Sen, Koushik and Agha, Gul},
  title     = {CUTE and JCUTE: Concolic Unit Testing and Explicit Path Model-Checking Tools},
  year      = {2006},
  isbn      = {354037406X},
  publisher = {Springer-Verlag},
  address   = {Berlin, Heidelberg},
  url       = {https://doi.org/10.1007/11817963_38},
  doi       = {10.1007/11817963_38},
  abstract  = {CUTE, a Concolic Unit Testing Engine for C and Java, is a tool to systematically and automatically test sequential C programs (including pointers) and concurrent Java programs. CUTE combines concrete and symbolic execution in a way that avoids redundant test cases as well as false warnings. The tool also introduces a race-flipping technique to efficiently test and model check concurrent programs with data inputs.},
  booktitle = {Proceedings of the 18th International Conference on Computer Aided Verification},
  pages     = {419–423},
  numpages  = {5},
  location  = {Seattle, WA},
  series    = {CAV'06}
}

@inproceedings{RaceDetection,
  author    = {Sen, Koushik and Agha, Gul},
  title     = {A Race-Detection and Flipping Algorithm for Automated Testing of Multi-Threaded Programs},
  year      = {2006},
  isbn      = {9783540708889},
  publisher = {Springer-Verlag},
  address   = {Berlin, Heidelberg},
  abstract  = {Testing concurrent programs that accept data inputs is notoriously hard because, besides the large number of possible data inputs, nondeterminism results in an exponentially large number of interleavings of concurrent events. In order to efficiently test shared-memory multithreaded programs, we develop an algorithm based on race-detection and flipping and illustrate how it can be combined with concolic execution (a simultaneous symbolic and concrete execution method) to test multi-threaded programs with data inputs. The goal of our algorithm is to minimize redundant executions while ensuring that all reachable statements in a program are executed. To achieve this, our algorithm explores all distinct causal structures of a multi-threaded program (i.e., the partial order among events generated during an execution). Because our algorithm is based on race-detection, it enables us to report potential data races and deadlocks. We have implemented our algorithm in a tool called jCUTE. We describe the results of applying jCUTE to real-world multi-threaded Java applications and libraries. In particular, we discovered several undocumented potential concurrency-related bugs in the widely used Java collection framework distributed with the Sun Microsystems' JDK 1.4.},
  booktitle = {Proceedings of the 2nd International Haifa Verification Conference on Hardware and Software, Verification and Testing},
  pages     = {166–182},
  numpages  = {17},
  location  = {Haifa, Israel},
  series    = {HVC'06}
}

@inproceedings{Pex,
  author    = {Tillmann, Nikolai
               and de Halleux, Jonathan},
  editor    = {Beckert, Bernhard
               and H{\"a}hnle, Reiner},
  title     = {Pex--White Box Test Generation for .NET},
  booktitle = {Tests and Proofs},
  year      = {2008},
  publisher = {Springer Berlin Heidelberg},
  address   = {Berlin, Heidelberg},
  pages     = {134--153},
  abstract  = {Pex automatically produces a small test suite with high code coverage for a .NET program. To this end, Pex performs a systematic program analysis (using dynamic symbolic execution, similar to path-bounded model-checking) to determine test inputs for Parameterized Unit Tests. Pex learns the program behavior by monitoring execution traces. Pex uses a constraint solver to produce new test inputs which exercise different program behavior. The result is an automatically generated small test suite which often achieves high code coverage. In one case study, we applied Pex to a core component of the .NET runtime which had already been extensively tested over several years. Pex found errors, including a serious issue.},
  isbn      = {978-3-540-79124-9}
}

@inproceedings{Fitnex,
  author    = {Xie, Tao and Tillmann, Nikolai and de Halleux, Jonathan and Schulte, Wolfram},
  booktitle = {2009 IEEE/IFIP International Conference on Dependable Systems \& Networks},
  title     = {Fitness-guided path exploration in dynamic symbolic execution},
  year      = {2009},
  volume    = {},
  number    = {},
  pages     = {359-368},
  doi       = {10.1109/DSN.2009.5270315}
}

@inproceedings{Moles,
  author    = {de Halleux, Jonathan
               and Tillmann, Nikolai},
  editor    = {Vitek, Jan},
  title     = {Moles: Tool-Assisted Environment Isolation with Closures},
  booktitle = {Objects, Models, Components, Patterns},
  year      = {2010},
  publisher = {Springer Berlin Heidelberg},
  address   = {Berlin, Heidelberg},
  pages     = {253--270},
  abstract  = {Isolating test cases from environment dependencies is often desirable, as it increases test reliability and reduces test execution time. However, code that calls non-virtual methods or consumes sealed classes is often impossible to test in isolation. Moles is a new lightweight framework which addresses this problem. For any .NET method, Moles allows test-code to provide alternative implementations, given as .NET delegates, for which C{\#} provides very concise syntax while capturing local variables in a closure object. Using code instrumentation, the Moles framework will redirect calls to provided delegates instead of the original methods. The Moles framework is designed to work together with the dynamic symbolic execution tool Pex to enable automated test generation. In a case study, testing code programmed against the Microsoft SharePoint Foundation API, we achieved full code coverage while running tests in isolation without an actual SharePoint server. The Moles framework integrates with .NET and Visual Studio.},
  isbn      = {978-3-642-13953-6}
}


@inproceedings{JPFSE,
  author    = {Anand, Saswat
               and P{\u{a}}s{\u{a}}reanu, Corina S.
               and Visser, Willem},
  editor    = {Grumberg, Orna
               and Huth, Michael},
  title     = {JPF--SE: A Symbolic Execution Extension to Java PathFinder},
  booktitle = {Tools and Algorithms for the Construction and Analysis of Systems},
  year      = {2007},
  publisher = {Springer Berlin Heidelberg},
  address   = {Berlin, Heidelberg},
  pages     = {134--138},
  abstract  = {We present JPF--SE, an extension to the Java PathFinder Model Checking framework (JPF) that enables the symbolic execution of Java programs. JPF--SE uses JPF to generate and explore symbolic execution paths and it uses off-the-shelf decision procedures to manipulate numeric constraints.},
  isbn      = {978-3-540-71209-1}
}


@article{JavaPathFinder,
  author   = {Havelund, Klaus
              and Pressburger, Thomas},
  title    = {Model checking JAVA programs using JAVA PathFinder},
  journal  = {International Journal on Software Tools for Technology Transfer},
  year     = {2000},
  month    = {03},
  day      = {01},
  volume   = {2},
  number   = {4},
  pages    = {366-381},
  abstract = {This paper describes a translator called Java PathFinder (Jpf), which translates from Java to Promela, the modeling language of the Spin model checker. Jpf translates a given Java program into a Promela model, which then can be model checked using Spin. The Java program may contain assertions, which are translated into similar assertions in the Promela model. The Spin model checker will then look for deadlocks and violations of any stated assertions. Jpf generates a Promela model with the same state space characteristics as the Java program. Hence, the Java program must have a finite and tractable state space. This work should be seen in a broader attempt to make formal methods applicable within NASA's areas such as space, aviation, and robotics. The work is a continuation of an effort to formally analyze, using Spin, a multi-threaded operating system for the Deep-Space 1 space craft, and of previous work in applying existing model checkers and theorem provers to real applications.},
  issn     = {1433-2779},
  doi      = {10.1007/s100090050043},
  url      = {https://doi.org/10.1007/s100090050043}
}

@article{SurveySymbex,
  author     = {Baldoni, Roberto and Coppa, Emilio and D’elia, Daniele Cono and Demetrescu, Camil and Finocchi, Irene},
  title      = {A Survey of Symbolic Execution Techniques},
  year       = {2018},
  issue_date = {May 2019},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {51},
  number     = {3},
  issn       = {0360-0300},
  url        = {https://doi.org/10.1145/3182657},
  doi        = {10.1145/3182657},
  abstract   = {Many security and software testing applications require checking whether certain properties of a program hold for any possible usage scenario. For instance, a tool for identifying software vulnerabilities may need to rule out the existence of any backdoor to bypass a program’s authentication. One approach would be to test the program using different, possibly random inputs. As the backdoor may only be hit for very specific program workloads, automated exploration of the space of possible inputs is of the essence. Symbolic execution provides an elegant solution to the problem, by systematically exploring many possible execution paths at the same time without necessarily requiring concrete inputs. Rather than taking on fully specified input values, the technique abstractly represents them as symbols, resorting to constraint solvers to construct actual instances that would cause property violations. Symbolic execution has been incubated in dozens of tools developed over the past four decades, leading to major practical breakthroughs in a number of prominent software reliability applications. The goal of this survey is to provide an overview of the main ideas, challenges, and solutions developed in the area, distilling them for a broad audience.},
  journal    = {ACM Comput. Surv.},
  month      = {05},
  articleno  = {50},
  numpages   = {39},
  keywords   = {Symbolic execution, static analysis, software testing, concolic execution}
}

@inproceedings{SurveyHybrid,
  author    = {Zhang, Tao and Jiang, Yu and Guo, Runsheng and Zheng, Xiaoran and Lu, Hui},
  title     = {A Survey of Hybrid Fuzzing Based on Symbolic Execution},
  year      = {2021},
  isbn      = {9781450387828},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/3444370.3444570},
  doi       = {10.1145/3444370.3444570},
  abstract  = {Fuzzing has now developed into an efficient method of vulnerability mining. Symbolic execution is also a popular software vulnerability mining technology. Both are research hotspots in the field of network and information security. Hybrid fuzzing is the addition of symbolic execution technology on the basis of traditional fuzzing, and has now developed into a new branch of fuzzing. This article studies the existing hybrid fuzzing methods, reviews the development and evolution process and technical core of hybrid fuzzing, and compares the performance of currently well-known hybrid fuzzing through an experimental method based on symbolic execution. Finally, it discusses the existing problems in the field of hybrid fuzzing testing, and tries to look forward to its future development trend.},
  booktitle = {Proceedings of the 2020 International Conference on Cyberspace Innovation of Advanced Technologies},
  pages     = {192–196},
  numpages  = {5},
  keywords  = {symbolic execution, Hybrid fuzzing, Fuzzing},
  location  = {Guangzhou, China},
  series    = {CIAT 2020}
}

@inproceedings{angr,
  author    = {Wang, Fish and Shoshitaishvili, Yan},
  booktitle = {2017 IEEE Cybersecurity Development (SecDev)},
  title     = {Angr - The Next Generation of Binary Analysis},
  year      = {2017},
  volume    = {},
  number    = {},
  pages     = {8-9},
  doi       = {10.1109/SecDev.2017.14}
}

@article{FUZZOLIC,
  title    = {FUZZOLIC: Mixing fuzzing and concolic execution},
  journal  = {Computers \& Security},
  volume   = {108},
  pages    = {102368},
  year     = {2021},
  issn     = {0167-4048},
  doi      = {https://doi.org/10.1016/j.cose.2021.102368},
  url      = {https://www.sciencedirect.com/science/article/pii/S0167404821001929},
  author   = {Luca Borzacchiello and Emilio Coppa and Camil Demetrescu},
  keywords = {Bug detection, Concolic execution, Fuzzing testing, SMT Solver, Hybrid fuzzing},
  abstract = {In the last few years, a large variety of approaches and methodologies have been explored in the context of software testing, ranging from black-box techniques, such as fuzzing, to white-box techniques, such as concolic execution, with a full spectrum of instances in between. Using these techniques, developers and security researchers have been able to identify in the last decade a large number of critical vulnerabilities in thousands of software projects. In this article, we investigate how to improve the performance and effectiveness of concolic execution, proposing two main enhancements to the original approach. On one side, we devise a novel concolic executor that can analyze complex binary programs while running under QEMU and efficiently produce symbolic queries, which could generate valuable program inputs when solved. On the other side, we investigate whether techniques borrowed from the fuzzing domain can be applied to solve the symbolic queries generated by concolic execution, providing a viable alternative to accurate but expensive SMT solving techniques. We show that the combination of our concolic engine, Fuzzolic, and our approximate solver, Fuzzy-Sat, can perform better in terms of code coverage than popular state-of-the-art fuzzers on a variety of complex programs and can identify different unknown bugs in several real-world applications.}
}

@inproceedings{CONFETTI,
  author    = {Kukucka, James and Pina, Lu\'{\i}s and Ammann, Paul and Bell, Jonathan},
  title     = {CONFETTI: Amplifying Concolic Guidance for Fuzzers},
  year      = {2022},
  isbn      = {9781450392211},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/3510003.3510628},
  doi       = {10.1145/3510003.3510628},
  abstract  = {Fuzz testing (fuzzing) allows developers to detect bugs and vulnerabilities in code by automatically generating defect-revealing inputs. Most fuzzers operate by generating inputs for applications and mutating the bytes of those inputs, guiding the fuzzing process with branch coverage feedback via instrumentation. Whitebox guidance (e.g., taint tracking or concolic execution) is sometimes integrated with coverage-guided fuzzing to help cover tricky-to-reach branches that are guarded by complex conditions (so-called "magic values"). This integration typically takes the form of a targeted input mutation, e.g., placing particular byte values at a specific offset of some input in order to cover a branch. However, these dynamic analysis techniques are not perfect in practice, which can result in the loss of important relationships between input bytes and branch predicates, thus reducing the effective power of the technique. We introduce a new, surprisingly simple, but effective technique, global hinting, which allows the fuzzer to insert these interesting bytes not only at a targeted position, but in any position of any input. We implemented this idea in Java, creating Confetti, which uses both targeted and global hints for fuzzing. In an empirical comparison with two baseline approaches, a state-of-the-art greybox Java fuzzer and a version of Confetti without global hinting, we found that Confetti covers more branches and finds 15 previously unreported bugs, including 9 that neither baseline could find. By conducting a post-mortem analysis of Confetti's execution, we determined that global hinting was at least as effective at revealing new coverage as traditional, targeted hinting.},
  booktitle = {Proceedings of the 44th International Conference on Software Engineering},
  pages     = {438–450},
  numpages  = {13},
  location  = {Pittsburgh, Pennsylvania},
  series    = {ICSE '22}
}

@article{Orchestrated,
  title    = {An orchestrated survey of methodologies for automated software test case generation},
  journal  = {Journal of Systems and Software},
  volume   = {86},
  number   = {8},
  pages    = {1978-2001},
  year     = {2013},
  issn     = {0164-1212},
  doi      = {https://doi.org/10.1016/j.jss.2013.02.061},
  url      = {https://www.sciencedirect.com/science/article/pii/S0164121213000563},
  author   = {Saswat Anand and Edmund K. Burke and Tsong Yueh Chen and John Clark and Myra B. Cohen and Wolfgang Grieskamp and Mark Harman and Mary Jean Harrold and Phil McMinn and Antonia Bertolino and J. {Jenny Li} and Hong Zhu},
  keywords = {Adaptive random testing, Combinatorial testing, Model-based testing, Orchestrated survey, Search-based software testing, Software testing, Symbolic execution, Test automation, Test case generation},
  abstract = {Test case generation is among the most labour-intensive tasks in software testing. It also has a strong impact on the effectiveness and efficiency of software testing. For these reasons, it has been one of the most active research topics in software testing for several decades, resulting in many different approaches and tools. This paper presents an orchestrated survey of the most prominent techniques for automatic generation of software test cases, reviewed in self-standing sections. The techniques presented include: (a) structural testing using symbolic execution, (b) model-based testing, (c) combinatorial testing, (d) random testing and its variant of adaptive random testing, and (e) search-based testing. Each section is contributed by world-renowned active researchers on the technique, and briefly covers the basic ideas underlying the method, the current state of the art, a discussion of the open research problems, and a perspective of the future development of the approach. As a whole, the paper aims at giving an introductory, up-to-date and (relatively) short overview of research in automatic test case generation, while ensuring a comprehensive and authoritative treatment.}
}

@inproceedings{Chopped,
  author    = {Trabish, David and Mattavelli, Andrea and Rinetzky, Noam and Cadar, Cristian},
  title     = {Chopped Symbolic Execution},
  year      = {2018},
  isbn      = {9781450356381},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/3180155.3180251},
  doi       = {10.1145/3180155.3180251},
  abstract  = {Symbolic execution is a powerful program analysis technique that systematically explores multiple program paths. However, despite important technical advances, symbolic execution often struggles to reach deep parts of the code due to the well-known path explosion problem and constraint solving limitations.In this paper, we propose chopped symbolic execution, a novel form of symbolic execution that allows users to specify uninteresting parts of the code to exclude during the analysis, thus only targeting the exploration to paths of importance. However, the excluded parts are not summarily ignored, as this may lead to both false positives and false negatives. Instead, they are executed lazily, when their effect may be observable by code under analysis. Chopped symbolic execution leverages various on-demand static analyses at runtime to automatically exclude code fragments while resolving their side effects, thus avoiding expensive manual annotations and imprecision.Our preliminary results show that the approach can effectively improve the effectiveness of symbolic execution in several different scenarios, including failure reproduction and test suite augmentation.},
  booktitle = {Proceedings of the 40th International Conference on Software Engineering},
  pages     = {350–360},
  numpages  = {11},
  keywords  = {static analysis, symbolic execution, program slicing},
  location  = {Gothenburg, Sweden},
  series    = {ICSE '18}
}

@article{Cyberdyne,
  author  = {Goodman, Peter and Dinaburg, Artem},
  journal = {IEEE Security \& Privacy},
  title   = {The Past, Present, and Future of Cyberdyne},
  year    = {2018},
  volume  = {16},
  number  = {2},
  pages   = {61-69},
  doi     = {10.1109/MSP.2018.1870859}
}

@article{DigFuzz,
  author  = {Zhao, Lei and Cao, Pengcheng and Duan, Yue and Yin, Heng and Xuan, Jifeng},
  journal = {IEEE Transactions on Dependable and Secure Computing},
  title   = {Probabilistic Path Prioritization for Hybrid Fuzzing},
  year    = {2022},
  volume  = {19},
  number  = {3},
  pages   = {1955-1973},
  doi     = {10.1109/TDSC.2020.3042259}
}

@inproceedings{GRT,
  author    = {Ma, Lei and Artho, Cyrille and Zhang, Cheng and Sato, Hiroyuki and Gmeiner, Johannes and Ramler, Rudolf},
  booktitle = {2015 30th IEEE/ACM International Conference on Automated Software Engineering (ASE)},
  title     = {GRT: Program-Analysis-Guided Random Testing (T)},
  year      = {2015},
  volume    = {},
  number    = {},
  pages     = {212-223},
  doi       = {10.1109/ASE.2015.49}
}

@inproceedings{BitBlaze,
  author    = {Dawn Song and David Brumley and Heng Yin and Juan Caballero and
               Ivan Jager and Min Gyung Kang and Zhenkai Liang and James Newsome and
               Pongsin Poosankam and Prateek Saxena},
  title     = {{BitBlaze}: A New Approach to Computer Security via Binary Analysis},
  booktitle = {Proceedings of the 4th International Conference on Information Systems Security. Keynote invited paper.},
  address   = {Hyderabad, India},
  year      = 2008,
  month     = dec
}

@inproceedings{CVCLite,
  author    = {Barrett, Clark
               and Berezin, Sergey},
  editor    = {Alur, Rajeev
               and Peled, Doron A.},
  title     = {CVC Lite: A New Implementation of the Cooperating Validity Checker},
  booktitle = {Computer Aided Verification},
  year      = {2004},
  publisher = {Springer Berlin Heidelberg},
  address   = {Berlin, Heidelberg},
  pages     = {515--518},
  abstract  = {We describe a tool called CVC Lite (CVCL), an automated theorem prover for formulas in a union of first-order theories. CVCL supports a set of theories which are useful in verification, including uninterpreted functions, arrays, records and tuples, and linear arithmetic. New features in CVCL (beyond those provided in similar previous systems) include a library API, more support for producing proofs, some heuristics for reasoning about quantifiers, and support for symbolic simulation primitives.},
  isbn      = {978-3-540-27813-9}
}

